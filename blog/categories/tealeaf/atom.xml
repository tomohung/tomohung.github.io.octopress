<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tealeaf | The Life Alchemist]]></title>
  <link href="http://www.tomohung.com/blog/categories/tealeaf/atom.xml" rel="self"/>
  <link href="http://www.tomohung.com/"/>
  <updated>2015-07-10T11:14:47+08:00</updated>
  <id>http://www.tomohung.com/</id>
  <author>
    <name><![CDATA[Tomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week8 (2/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-2/"/>
    <updated>2015-05-07T15:43:10+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-2</id>
    <content type="html"><![CDATA[<h1>Handle Payments Failures</h1>

<p>Here we review what Jason Fried said in <a href="https://signalvnoise.com/posts/753-ask-37signals-how-do-you-process-credit-cards">How Do You Process Credit Card</a>:</p>

<blockquote><p>The one thing we’re often surprised by is how many accounts have charge issues so it’s important to really think about the error handling and customer experience issues related to declined cards.</p></blockquote>

<p>So there are thousands of reasons a credit card may become declined after user register our website. It&rsquo;s important to handle these payment failures.</p>

<p>Stripe also provide the test situation for us.</p>

<blockquote><p>Card Number: <code>4000000000000341</code><br/>
Description: <code>Attaching this card to a Customer object will succeed, but attempts to charge the customer will fail.</code></p></blockquote>

<p>This special card number will create a customer but charge will fail.</p>

<p>We may produce failed webhook event by Stripe Dashboard.</p>

<p>Open <code>Payments</code> on dashboard and click <code>Create Payment</code>, input the above invalid Card Number info and click Done. Then we can find a failure charge in <code>Events &amp; Webhooks</code>.</p>

<p>As the previous post, we can get failed data as <code>:event_data</code> for test:</p>

<pre><code class="ruby spec/requests/deactivate_user_with_payment_failure">describe 'customer on failed charge' do
  let(:event_data) do
    {
      "id" =&gt; "evt_15ycOeLCTUylKIRlJom1jayI",
      "created" =&gt; 1430718340,
      "livemode" =&gt; false,
      "type" =&gt; "charge.failed",
      "data" =&gt; {
        "object" =&gt; {
          "id" =&gt; "ch_15ycOdLCTUylKIRlq8G764Gc",
          "object" =&gt; "charge",
          "created" =&gt; 1430718339,
          "livemode" =&gt; false,
          "paid" =&gt; false,
          "status" =&gt; "failed",
          # .......
          "application_fee" =&gt; nil,
          "refunds" =&gt; {
            "object" =&gt; "list",
            "total_count" =&gt; 0,
            "has_more" =&gt; false,
            "url" =&gt; "/v1/charges/ch_15ycOdLCTUylKIRlq8G764Gc/refunds",
            "data" =&gt; []
          }
        }
      },
      "object" =&gt; "event",
      "pending_webhooks" =&gt; 1,
      "request" =&gt; "iar_6AyLkbPGvZltpn",
      "api_version" =&gt; "2015-04-07"
    }
  end
end
</code></pre>

<p>Notice that <code>:event_data</code> type is <code>charge.failed</code>.</p>

<p>Then we add event <code>charge.failed</code> in <code>strip.rb</code></p>

<pre><code class="ruby config/initializers/stripe.rb">StripeEvent.configure do |events|
  events.subscribe 'charge.failed' do |event|
    user = User.find_by(customer_token: event.data.object.customer)
    user.deactivate!
  end
end
</code></pre>

<p>We simplpy deactivate user here, usually, it should send a warning mail to the user.</p>

<p>Here is the request test:</p>

<pre><code class="ruby spec/requests/deactivate_user_with_payment_failure">describe 'customer on failed charge' do
  let(:event_data) do
    #...
  end

  it 'deactivates a user with the webhook data from stripe for charge failed', vcr: true do
    user = Fabricate(:user, customer_token: "cus_6Awy7ItkTK5HCv", active: true)
    post '/stripe_events', event_data
    expect(user.reload).not_to be_active
  end
end
</code></pre>

<p>We need to add column <code>active</code> for <code>User</code> to store the status.</p>

<pre><code class="ruby">add_column :users, :active, :boolean, default: true
</code></pre>

<p>Make the <code>active</code> column default is true, otherwise Rails will set <code>false</code> for default value.</p>

<h1>A Short Conclusion for Stripe</h1>

<p>We cover Stripe for last three weeks.</p>

<ul>
<li><p>In week 6, we introduce Stripe for charge. How to build a custom form to charge. And test by using <code>vcr</code> for replay response.</p></li>
<li><p>In week 7, we refactor code into <code>UserSignup</code>, as an <code>Service Object</code> of OOP concept. And we need to use javascript driver <code>webkit</code> and <code>selenium</code> in RSpec because of Stripe api.</p></li>
<li><p>In week 8, we use <code>Subscription</code> to charge monthly instead of charge once. And we handle events by <code>Webhook</code>, to deal with <code>charge.succeeded</code> and <code>charge.failed</code> events.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week8 (1/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-1/"/>
    <updated>2015-05-07T10:40:17+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-1</id>
    <content type="html"><![CDATA[<h1>Subscription</h1>

<p>This week it&rsquo;s still about Stripe. Last week, we use Stripe to charge once, and Stripe also offer us to charge  monthly. This is called <code>Subscription</code>.</p>

<p>First following the <a href="https://stripe.com/docs/subscriptions">instruction here</a> to set Plan.</p>

<p>Then write the test for <code>customer charge</code></p>

<pre><code class="ruby">describe StripeWrapper, vcr: true do
  describe "StripeWrapper::customer" do
    it 'create a customer with valid card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: valid_token, email: user.email)
      expect(charge).to be_success
    end

    it 'does not create a customer with declined card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: invalid_token, email: user.email)
      expect(charge).not_to be_success
    end

    it 'return error message with declined card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: invalid_token, email: user.email)
      expect(charge.error_message).to be_present
    end

    it 'returns the customer token for a valid card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: valid_token, email: user.email)
      expect(charge.customer_token).to be_present
    end
  end
end
</code></pre>

<p><code>StripeWrapper::Charge.customer</code> is written like this:</p>

<pre><code class="ruby models/stripe_wrapper.rb">module StripeWrapper
  class Charge
    attr_reader :response, :status

    def self.customer(options = {})    
      begin
        response = Stripe::Customer.create(
          source: options[:source],
          plan: "BASE",
          email: options[:email]
        )
        new(response, :success)
      rescue Stripe::CardError =&gt; e
        new(e, :error)
      end
    end
  end
end
</code></pre>

<p>Here is a tip, in Week7, since we merge code into <code>UserSignup</code> service object, although we change behavior from <code>charge</code> to <code>customer</code>, it&rsquo;s unrelated to <code>UsersControler#create</code> code.</p>

<pre><code class="ruby users_controller.rb">  #some code...
  user_signup_service = UserSignup.new(@user)
  result = user_signup_service.sign_up(params[:stripeToken], params[:token])
</code></pre>

<p>We only need to modified code in <code>UserSignup.sign_up</code>.</p>

<pre><code class="ruby services/user_signup.rb">  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        #do something...
      else
        #do something...
      end
    else
      #do something...
    end
  end

  def customer_charge_user_with_stripe(token)
    StripeWrapper::Charge.customer(
      source: token,
      email: @user.email
    )
  end
</code></pre>

<h1>Stripe Webhooks</h1>

<p>We can review Stripe payments on Stripe&rsquo;s dashboard, but what if we want to track and save these records in our website?</p>

<p>Here we instroduce <a href="https://stripe.com/docs/webhooks">Webhook</a></p>

<p>We need Stripe to trigger an event for our server, then we can hold response from Stripe into our database.</p>

<ol>
<li>Go <code>Account setting</code>-><code>Webhooks</code>-><code>Add endpoint...</code></li>
<li>Input your website url. &lt;- explain it later</li>
<li>Select test mode, and press Done</li>
<li>Click <code>Send test webhook</code></li>
</ol>


<p>For developement, we use <a href="http://requestb.in/">RequestBin</a> here to inspect HTTP requests.</p>

<p>Create a RequestBin Url for Stripe endpoint, from the link above, and input the url to Step 2. Click <code>Send test webhook</code> and go back refresh RequestBin page, you will see the response.</p>

<p>Instead of this, we also can review the response from Stripe <code>dashboard</code>-><code>Events &amp; Webhooks</code>, select one of record and check the <code>Webhook Details</code>.</p>

<p>Why we want to check response here? It&rsquo;s just prepared for test data.</p>

<p>For example, create a RSpec file for <code>succeeded payment</code>, and convert response to a fake data <code>:event_data</code></p>

<pre><code class="ruby ">describe "Create payment on successful charge" do
  let(:event_data) do
    {
      "id"=&gt; "evt_15yYzgLCTUylKIRln74HkdCq",
      "created"=&gt; 1430705260,
      "livemode"=&gt; false,
      "type"=&gt; "charge.succeeded",
      "data"=&gt; {
        "object"=&gt; {
          "id"=&gt; "ch_15yYzgLCTUylKIRlP66CKpX5",
          "object"=&gt; "charge",
          "created"=&gt; 1430705260,
          "livemode"=&gt; false,
          "paid"=&gt; true,
          "status"=&gt; "succeeded",
          "amount"=&gt; 99,
          "currency"=&gt; "usd",
          "refunded"=&gt; false,
          "source"=&gt; {
            "id"=&gt; "card_15yYzeLCTUylKIRll7zhkfMs",
            "object"=&gt; "card",
            #.........
            "dynamic_last4"=&gt; nil,
            "metadata"=&gt; {},
            "customer"=&gt; "cus_6Aupm1THLvHTnO"
          },
          "captured"=&gt; true,
          "balance_transaction"=&gt; "txn_15yYzgLCTUylKIRluBT7Obmz",
          "failure_message"=&gt; nil,
          "failure_code"=&gt; nil,
          "amount_refunded"=&gt; 0,
          "customer"=&gt; "cus_6Aupm1THLvHTnO",
          "invoice"=&gt; "in_15yYzgLCTUylKIRlcnjWhIBb",
          "application_fee"=&gt; nil,
          #..............
          "refunds"=&gt; {
            "object"=&gt; "list",
            "total_count"=&gt; 0,
            "has_more"=&gt; false,
            "url"=&gt; "/v1/charges/ch_15yYzgLCTUylKIRlP66CKpX5/refunds",
            "data"=&gt; []
          }
        }
      },
      "object"=&gt; "event",
      "pending_webhooks"=&gt; 1,
      "request"=&gt; "iar_6AupyN8zrE6fF4",
      "api_version"=&gt; "2015-04-07"
    }    
  end

  #some spec here...
end
</code></pre>

<p>According to the data, the event type is <code>charge.succeeded</code>.</p>

<p>In order to receive Stripe Webhook event, we need the gem <code>stripe_event</code></p>

<pre><code>gem 'stripe_event'
</code></pre>

<p>In config/routes.rb</p>

<pre><code>mount StripeEvent::Engine, at: '/stripe_events' # provide a custom path
</code></pre>

<p>Get mark here for the path <code>/stripe_events</code>, because it&rsquo;s the endpoint for setting webhook in Stripe&rsquo;s account setting. Create a webhook on Stripe, for example, my website is <code>https://tomo-myflix.herokuapp.com</code>, then endpoint url is <code>https://tomo-myflix.herokuapp.com/stripe_events</code></p>

<p>Then Stripe_Event help us to deal with stripe events here:</p>

<pre><code class="ruby config/initializers/stripe.rb">StripeEvent.configure do |events|
  events.subscribe 'charge.succeeded' do |event|
    user = User.find_by(customer_token: event.data.object.customer)
    Payment.create(user: user, amount: event.data.object.amount, reference_id: event.data.object.id)
  end
end
</code></pre>

<p><code>customer_token</code> is created when creating <code>User</code>. Add this column in <code>User</code> to track Stripe record. And code this in service object <code>UserSignup.sign_up</code>:</p>

<pre><code class="ruby models/user_signup.rb">#....
  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        @user.customer_token = charge.customer_token
        @user.save
# ....
</code></pre>

<p><code>customer_token</code> and <code>amount</code> can get from response <code>event.data.object</code>.</p>

<p>If your development follow the TDD process, here should code the test first like this</p>

<pre><code class="ruby spec/requests/create_payment_on_successful_charge_spec.rb">describe "Create payment on successful charge" do
  let(:event_data) do 
    # setting in above, ignore here.
  end

  it 'creates a payment with webhood from stripe for charge succeed', vcr: true do
    post '/stripe_events', event_data
    expect(Payment.count).to eq(1)
  end

  # other tests....
end  
</code></pre>

<p>Notice that we use <code>post '/stripe_events', event_data</code> to simulate Stripe emit a post to our server. So this is only for test to trigger StripeEvent in <code>initializers/stripe.rb</code>.</p>

<p>So far, we can create <code>Payment</code> by Stripe Webhook.</p>

<h1>ngrok for local test</h1>

<p>When we run the server on localhost, there is no way to let Stripe directly emit the post to our local machine. And we can use <code>ngrok</code> to do the response transfer.</p>

<p>Download <a href="https://ngrok.com/">ngrok</a> and install.</p>

<pre><code class="ruby">$ngrok 3000
</code></pre>

<p>Get an URL from ngrok, and set this url to Stripe Webhook endpoint. Run the rails server, and operate app by manual to check if payment record be saved.</p>

<p>Just a memo here, becuase I can&rsquo;t use ngrok on my Mac(looks like security problem). but it&rsquo;s ok because I test successful on Heroku.</p>

<p>The most important here is to set the app stirpe events URL in Stripe, for example my end point is:</p>

<pre><code>https://tomo-myflix.herokuapp.com/stripe_events
</code></pre>

<h1>ATDD for payment view</h1>

<p>The process for <code>admin views payment</code> is not very complex, so we can just write the spec outside-in, some also call this <code>ATDD</code>.</p>

<p>Here is a post talking about the <a href="http://gaboesquivel.com/blog/2014/differences-between-tdd-atdd-and-bdd/">differences between TDD, ATDD, BDD</a>.</p>

<pre><code class="ruby">feature 'Admin sees payments' do
  scenario 'admin can see payments' do
    user = Fabricate(:user)
    payment = Payment.create(user: user, reference_id: 'fake_reference_id', amount: 99)
    sign_in(Fabricate(:admin))
    visit admin_payments_path
    expect(page).to have_content("$0.99")
    expect(page).to have_content(user.email)
    expect(page).to have_content(user.full_name)
    expect(page).to have_content('fake_reference_id')
  end

  scenario 'user cannot see payments' do
    sign_in(Fabricate(:user))
    visit admin_payments_path
    expect(page).to have_content("You do not have access right.")
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (3/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3/"/>
    <updated>2015-05-06T17:22:47+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3</id>
    <content type="html"><![CDATA[<h1>Messsage Expectation</h1>

<p>We has metioned <a href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1/">Test Double at post (1/3)</a>, and here is another kind of Test Double, called <code>Mock Objects</code>.</p>

<blockquote><p>Assert communication, not response</p></blockquote>

<p>In previous post, we have moved the code into <code>UserSignup</code> services obejct and test it. And here all we need to test is ensure that <code>:sign_up</code> method is called in <code>UsersController#create</code>.</p>

<pre><code>describe UsersController do
  describe 'POST create' do
    context 'with valid input' do

      it 'should logged_in if create user' do
        result = double(:sign_up, successful?: true)
        expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)
        expect_any_instance_of(User).to receive(:id).and_return(1)
        post :create, user: Fabricate.attributes_for(:user)
        expect(session[:user_id]).to eq(1)
      end
    end
  end
end
</code></pre>

<p><code>expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)</code> is called <code>Message Expectation</code> in RSpec, a kind of <code>Mock Object</code>.</p>

<p>Refer to RSpec, it defines</p>

<blockquote><h3>Mock Objects and Test Stubs</h3>

<p>The names Mock Object and Test Stub suggest specialized Test Doubles. i.e. a Test Stub is a Test Double that only supports method stubs, and a Mock Object is a Test Double that supports message expectations and method stubs.</p>

<p>There is a lot of overlapping nomenclature here, and there are many variations of these patterns (fakes, spies, etc). Keep in mind that most of the time we&rsquo;re talking about method-level concepts that are variations of method stubs and message expectations, and we&rsquo;re applying to them to one generic kind of object: a Test Double.</p></blockquote>

<h1>Test Minimalist</h1>

<p>Here we got 3 resources of discussion test.</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=R9FOchgTtLM">Why you don&rsquo;t get mock objects</a> by Gregory</li>
<li><a href="http://martinfowler.com/articles/mocksArentStubs.html">Mock Aren&rsquo;t Stub</a> by Mark Folwer</li>
<li><a href="https://www.youtube.com/watch?v=URSWYvyc42M">The Magic tricks of Testing</a> by Sandi Mets</li>
</ul>


<p>Summary for these three resources.</p>

<p>I use Sandi&rsquo;s picture for the start:</p>

<p><img class="<a" src="href="http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png">http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png</a>&#8221;></p>

<p>Use this week assignment, class <code>UserSignup</code> for example:</p>

<ul>
<li><p>Incoming Query: We test UserSignup method <code>sign_up</code>, and expect it returns an successful object with valid info. This spec is testing this object state.</p></li>
<li><p>Incoming Command: We also test UserSignup method <code>sign_up</code>, and expect it should create an user with valid info. This is what Sandi said: side effects for outside.</p></li>
</ul>


<blockquote><p>Incoming Command and Incoming Query are all what Mark Folwer said State or Stub or Classical.</p></blockquote>

<ul>
<li><p>Sent to Self: According to Sandi&rsquo;s opinion, it&rsquo;s not necessary to test all private methods in class. Maybe for the complex method, we should think if we can abstract some logic into a new class, and give that class another tests if we need it.</p></li>
<li><p>Outgoing Query: Sandi ignore this, I guess she means that once the object send a new query to the other object, all we need to do is make sure that the other object works fine. And this should be test on that object, so we don&rsquo;t need to test outgoing query.</p></li>
<li><p>Outgoing Command: Once we let an object send a message to the other object do some side effects, all we need to do is make sure that this object do send a message. And this is method message expectation in RSpec, also Mark Folwer said behavior or Mockist or &lsquo;Mock&rsquo;.</p></li>
</ul>


<p>Gregory and Sandi all said that Mock Object can loose each objects association when testing. Once we are testing behavior( or maybe I can say testing interface), we don&rsquo;t need to bind the test and method with specific variable, but bind with an interface. It looks like apply OO concept on testing - try to loose connection with each objects, also loose each object&rsquo;s tests.</p>

<p>Kevin also metions this:</p>

<blockquote><p>a pure &ldquo;mockist&rdquo; way of doing test can be difficult in Rails apps, because in rails apps persistence is handled by the framework and for small apps most of object collaboration / message sending are about persistence. If you mock those interfaces, you end up mocking the guts of rails and that typically doesn&rsquo;t end up well.  this is also why we only touch this topic in the context of non rails objects like service objects.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (2/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-2/"/>
    <updated>2015-05-06T15:42:37+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-2</id>
    <content type="html"><![CDATA[<h1>Beyond MVC</h1>

<p>Rails built on MVC (Model / View / Controller) structure. And something get complex if we got more code and logic. This is why we need design patterns.</p>

<h2>Decorators</h2>

<p>Some tips from gem <code>Draper</code>:</p>

<blockquote><p>Without Draper, this functionality might have been tangled up in procedural helpers or adding bulk to your models. With Draper decorators, you can wrap your models with presentation-related logic to organise - and test - this layer of your app much more effectively.</p></blockquote>

<p>Or</p>

<blockquote><p>Decorators are the ideal place to:</p>

<ul>
<li>format complex data for user display</li>
<li>define commonly-used representations of an object, like a <code>name</code> method that combine <code>first_name</code> and <code>last_name</code> attributes.</li>
<li>mark up attributes with a little semantic HTML, like turning a url fiedl into a hyperlink.</li>
</ul>
</blockquote>

<p>First, install gem</p>

<pre><code>gem 'draper'
</code></pre>

<pre><code class="ruby app/decorator/video_decorator.rb">class VideoDecorator &lt; Draper::Decorator
  delegate_all

  def rating
    "Rating: " + (object.rating.present? ? "#{object.rating}/5.0" : "NA")
  end
end
</code></pre>

<p>And use it in controller</p>

<pre><code class="ruby videos_controller.rb">  def show
    @video = VideoDecorator.decorate(Vidoe.find(params[:id]))
  dne
</code></pre>

<p>In view, just a clear line code.</p>

<pre><code class="ruby app/views/videos/show.html.haml">  = @video.rating
</code></pre>

<p>The key point here is that we have a model data (rating) associated with view, it&rsquo;s not suitable to put to <code>view helper</code> (some logic with model). That&rsquo;s why here using decorator to encapsulate presentation logic.</p>

<h2>Policy Objects</h2>

<p>Define what is premium user:</p>

<pre><code class="ruby models/user_level_policy.rb">class UserLevelPolicy
  attr_reader :user
  def initialize(user)
    @user = user
  end

  def premium?
    user.created_at &lt; Date.new(2010,1,1) || user.plan.premium?
  end
end
</code></pre>

<p>In Controller</p>

<pre><code class="ruby todo_controller.rb">###some code

  if UserLevelPolicy.new(current_user).premium?
    #do something
  else
    #do another thing
  end
</code></pre>

<p>Different with Decorators, Policy Ojbects only concern judgement logic into one place, without presentation concerned.</p>

<h2>Domain Objects</h2>

<p>if <code>User</code> has an attribute <code>credit_balance</code>. Then merge those code relative to <code>credit</code> into Domain Object.</p>

<pre><code class="ruby models/credit.rb">class Credit
  attr_accessor :credit_balance, :user

  def initialize(user)
    @credit_balance = user.current_credit_balance
    @user = user
  end

  def -(number)
    credit_balance = credit_balance - number
  end

  def save
    user.current_credit_balance = credit_balance
    user.save
  end

  def depleted?
    credit_balance &lt; 0
  end

  def low_balance?
    credit_balance &lt; 10
  end
end
</code></pre>

<p>Thus <code>Credit.new(current_user)</code> can call methods about credit, and don&rsquo;t need to put these code in model <code>User</code>, or <code>UsersController</code>.</p>

<h2>Service Objects</h2>

<p>We abstract an action as <code>sign up</code> in <code>UsersController#create</code>.</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def create    
    @user = User.new(user_params)
    user_signup_service = UserSignup.new(@user)
    result = user_signup_service.sign_up(params[:stripeToken], params[:token])

    if result.successful?
      session[:user_id] = @user.id
      redirect_to home_path
    else
      flash.now[:danger] =  user_signup_service.error_message
      render :new
    end
  end
end
</code></pre>

<p>Then create an service object <code>UserSignup</code> to handle this.</p>

<pre><code class="ruby app/service/user_signup.rb">class UserSignup

  attr_reader :error_message

  def initialize(user)
    @user = user
  end

  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        @user.customer_token = charge.customer_token
        @user.save
        set_invitation_following_relationship(invitation_token)
        AppMailer.delay.send_welcome_email(@user)
        @status = :success
        self
      else
        @status = :failed
        @error_message = charge.error_message
        self
      end
    else
      @status = :failed
      @error_message = "User info is invalid."
      self
    end
  end

  def successful?
    @status == :success
  end
end
</code></pre>

<p>There is an article from Code Climate <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models</a></p>

<p>As it metion when to use Service Object:</p>

<ul>
<li>The action is complex (e.g. closing the books at the end of an accounting period)</li>
<li>The action reaches across multiple models (e.g. an e-commerce purchase using Order, CreditCard and Customer objects)</li>
<li>The action interacts with an external service (e.g. posting to social networks)</li>
<li>The action is not a core concern of the underlying model (e.g. sweeping up outdated data after a certain time period).</li>
<li>There are multiple ways of performing the action (e.g. authenticating with an access token or password). This is the Gang of Four Strategy pattern.</li>
</ul>


<h2>Some Concept for Object Oriented Design</h2>

<ul>
<li><p><code>Fat model, skinny controllers</code> makes model uncontrollrable. That&rsquo;s why we need Object Oriented Design</p></li>
<li><p>YAGNI</p></li>
</ul>


<p>YAGNI means <code>You Aren't Gonna Need It!</code></p>

<p>Don&rsquo;t write the code you haven&rsquo;t need it.</p>

<p>Here is aother post talking about <code>YAGNI</code>, <code>KISS</code>, <code>DRY</code>.
<a href="http://www.itexico.com/blog/bid/99765/Software-Development-KISS-YAGNI-DRY-3-Principles-to-simplify-your-life">Software Development: KISS, YAGNI &amp; DRY. 3 Principles to simplify your life.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (1/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1/"/>
    <updated>2015-05-06T14:20:15+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1</id>
    <content type="html"><![CDATA[<p>Last week, we use Stripe for charge in UsersController#create, it&rsquo;s a bit little complex code here. We need to wrap it.</p>

<p>Why we need to wrap it into a class:</p>

<ol>
<li><p>Easy to maintain code, isolate controller&rsquo;s and business logic. Remember we knew that <code>fat models, thin controllers</code>, here is a step further concept, we encapsulate code into <code>models/stripe_wrapper.rb</code></p></li>
<li><p>Easy to test, isolate test between different object is always a good idea.</p></li>
</ol>


<h1>How to Wrap</h1>

<p>For <code>module StripeWrapper</code> is just a namespace. Then we sort the code in UsersController#create,</p>

<pre><code>module StripeWrapper
  class Charge
    attr_reader :response, :status

    def initialize(response, status)
      @response = response
      @status = status
    end

    def self.create(options = {})      
      begin
        response = Stripe::Charge.create(
          amount: options[:amount], # amount in cents, again
          currency: "usd",
          source: options[:source],
          description: options[:description]
        )
        new(response, :success)
      rescue Stripe::CardError =&gt; e
        new(e, :error)
      end
    end

    def success?
      status == :success
    end

    def error_message
      response.message
    end
  end

  def self.set_api_key
    Stripe.api_key = ENV["STRIPE_SECRET_KEY"]
  end
end
</code></pre>

<p>Then we can call method <code>StripeWrapper::Charge(options)</code>.</p>

<p><code>new(repose, :sucess)</code> and <code>new(e, :error)</code> return an <code>StripeWrapper::Charge</code> object result.</p>

<h1>How to Test StripeWrapper</h1>

<p>Test return object <code>charge</code>:</p>

<pre><code>describe StripeWrapper do
  describe StripeWrapper::Charge do
    it 'makes successful charge' do
      charge = StripeWrapper::Charge.create(amount: 100, source: valid_token)
      expect(charge.response.amount).to eq(100)
      expect(charge.response.currency).to eq('usd')
      expect(charge).to be_success
    end
  end
end
</code></pre>

<p>But there is a problem, everytime we test, it will send a request to Stripe server. We don&rsquo;t want to do this and want to reduce test consumer time, use gem <code>vcr</code>.</p>

<pre><code>$ gem install vcr
$ gem install webmock
</code></pre>

<p>Then add <code>vcr: true</code> to spec</p>

<pre><code>it 'make successful charge', vcr: true do
  #something
end
</code></pre>

<p>vcr will record the reponse in <code>spec/cassettes</code>, when next time it find that test emit the same request again, it will not send the request outside to the server, but replaying saved response.</p>

<p>Here is vcr setting:</p>

<pre><code class="ruby spec_helper.rb">require 'vcr'

VCR.configure do |c|
  c.cassette_library_dir = 'spec/cassettes'
  c.hook_into :webmock
  c.configure_rspec_metadata!
  c.ignore_localhost = true
end
</code></pre>

<h1>How to test Controller#create</h1>

<p>Since we have test StripeWrapper, we don&rsquo;t want to test it again in Controller, or hit the Stripe server again. Use <a href="http://en.wikipedia.org/wiki/Test_double">Test Double</a> <code>stub</code> here.</p>

<p>For example, if we have a <code>PaymentController</code>:</p>

<pre><code>describe PaymentController do
  describe 'POST create' do
    it 'sets the flash success message' do
      charge = double("charge")
      charge.stub(:successful?).and_return(true)
      StripeWrapper::Charge.stub(:create).and_return(charge)
      post :create, token: "fake_token"
      expect(flash[:success]).to be_present
    end
  end
end
</code></pre>

<ol>
<li>Create a test stub <code>charge</code>, and stub a method <code>successful?</code> and return <code>true</code>.</li>
<li>stub <code>:create</code> method to <code>StripeWrapper::Charge</code> and return <code>charge</code>.</li>
</ol>


<p>Now we strike <code>post :create</code>, in PaymentController#create when running to code StripeWrapper::Charge, it will return a result <code>charge</code> with <code>charge.successful?</code> is <code>true</code>.</p>

<p>We do this is because make this controller#create test itself independently, and all we need to do is set StripeWrapper return successful.</p>

<blockquote><p>StripeWrapper will make a HTTP request, we can use <code>vcr</code> to record this, but it&rsquo;s not necessary becuase this test is already done in stripe_wrapper_spec. So here we choose to use <code>stub</code>.</p></blockquote>

<h1>How to do Feature Test with JavaScript</h1>

<p>Since we use javascript in view form, we need to turn on <code>:js</code></p>

<pre><code>feature 'visitor make payment' do
  scenario 'with valid card number', js: true do
    visit new_payment_path
    fill_in "Credit Card Number", with "424242424242424242"
    fill_in "Security Code", with "123"
    select "3 - March", form: "date_month"
    select "2015", from: "date_year"
    click_button "Submit Payment"

    expect(page).to have_content "Successful charge."
  end
end
</code></pre>

<p>Install gem</p>

<pre><code>gem 'selenium-webdriver'
gem 'capybara-webkit'
</code></pre>

<p>And set in <code>spec_helper.rb</code></p>

<pre><code class="ruby">Capybara.javascript_driver = :webkit # For default javascript server
Capybara.server_port = 52662 # For Selenium
</code></pre>

<p><code>webkit</code> is offered by <code>Qt</code> framework, it&rsquo;s faster than <code>Selenium</code> and invisible. <code>Selenium</code> process is visible, so it&rsquo;s suit for debug.</p>

<p>Careful when test in Email Invitation, I need to use <code>Selenium</code> instead of <code>webkit</code>, otherwise the test will be failed.</p>

<pre><code>scenario 'User successfully invites friend and invitation is accepted', {js: true, vcr: true, driver: :selenium} do
</code></pre>

<h2>Setting <a href="https://github.com/DatabaseCleaner/database_cleaner">database_cleaner</a></h2>

<p>It will lead a problem when we run javascript test, refer from RSpec doc:</p>

<blockquote><p>drivers which run the server in a different thread may not share the same transaction as your tests, causing data not to be shared between your test and test server.</p></blockquote>

<p>The problem is when running javascript, activerecord may delete database before javascript test finish.</p>

<p>We can use <code>database_cleaner</code> to do <code>truncation</code> instead of <code>transaction</code>. Manual create and destroy records.</p>

<pre><code>RSpec.configure do |config|
  config.use_transactional_fixtures = false

  config.before(:suite) do
    DatabaseCleaner.clean_with(:truncation)
  end

  config.before(:each) do
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each, :js =&gt; true) do
    DatabaseCleaner.strategy = :truncation
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
</code></pre>
]]></content>
  </entry>
  
</feed>
