<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Eloquent Ruby | The Life Alchemist]]></title>
  <link href="http://www.tomohung.com/blog/categories/eloquent-ruby/atom.xml" rel="self"/>
  <link href="http://www.tomohung.com/"/>
  <updated>2016-06-24T22:29:41+08:00</updated>
  <id>http://www.tomohung.com/</id>
  <author>
    <name><![CDATA[Tomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -9 [Write Specs!]]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/19/eloquent-ruby-9/"/>
    <updated>2015-05-19T09:11:44+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/19/eloquent-ruby-9</id>
    <content type="html"><![CDATA[<h1>Chapter 9 - Write Specs!</h1>

<h2>Don&rsquo;t test it, Spec it!</h2>

<p>雖然內建MiniTest，但實際上寫測試的思維可以像是在定義規格，這也是<code>RSpec</code>的出發點。</p>

<p>在描述上更接近口語的方式：</p>

<pre><code>doc.words.include?('blog') == true

#==&gt; RSpec
doc.words should include('blog')
</code></pre>

<h2>Easy Stubs</h2>

<p>理想上最好測試一次只測一個類別，但實際上很困難，所以可以利用stub來隔開同時間操作不同的類別。
概念上就是如果需要呼叫外部其它的類別時，賦值給其呼叫的函數</p>

<pre><code>stub_outputer = stub :available? =&gt; true, :render =&gt; nil
</code></pre>

<p>如此當stub_outputer.availabe? 回傳true, stub_outputer.render回傳nil。</p>

<h2>Easy Mocks</h2>

<p>不同於Stubs，我們希望在測試的函數中，有呼叫到另一個函數，在這裡不用考慮這個函數是否運作正常（這個動作應該在該類別中測試），所以我們期望在這個函數中有呼叫即可</p>

<pre><code class="ruby">it 'should know how to output' do
  mock_outputer = mock('Printer') # &lt;== mock objects
  mock_outputer.should_receive(:available?).and_return(true)  # &lt;== expectation call
  @doc.output(mock_outputer).should == 'Done' # &lt;== :avaliable? should be called in output method.
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -8 [Embrance Dynamic Typing]]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/19/eloquent-ruby-8/"/>
    <updated>2015-05-19T08:56:30+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/19/eloquent-ruby-8</id>
    <content type="html"><![CDATA[<h1>Chapter 8 - Embrance Dynamic Typing</h1>

<h2>不需要抽象類別</h2>

<p>在C++中，通常會先定義一個抽象類別讓其它類別來繼承並實現其中的Virtual Function，但是在Ruby中這個動作是多餘的。只要類別中有同名的method即可。</p>

<p>例如有二個類別<code>Document</code>, <code>LazyDocument</code>，其中<code>Document</code>的method <code>title</code>是回傳宣告時的值，而<code>LazyDocument</code>是回傳宣告時讀入檔案的值。我們不需要另外定義一個<code>BaseDocument</code>，其中還定義了<code>title</code>這個virtual method，這是一個多餘的動作。</p>

<p>所以有人說對Ruby來說，只要這個類別會像鴨子一樣呱呱叫（譬如就是有<code>make_sound</code>這個method），就可以把它當作鴨子。缺點就是如果沒注意的話，很容易在runtime時期遇到<code>undefined method</code>的問題。</p>

<h2>總結</h2>

<p>這章大部份都是舉例，總結最後</p>

<ul>
<li>只實作你需要的方法</li>
<li>利用命名來documentation</li>
<li>記得要寫test</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -7 [Treat Everything Like an Object—Because Everything Is]]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/04/eloquent-ruby-7/"/>
    <updated>2015-05-04T06:19:26+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/04/eloquent-ruby-7</id>
    <content type="html"><![CDATA[<h1>Chapter 7 - Treat Everything Like an Object—Because Everything Is</h1>

<h2>Classes, Instances, Methods</h2>

<ul>
<li><p>Class就像是容器，可以裝很多Method。Class也像是工廠，製造出很多副本Instances</p></li>
<li><p>如果沒有指定superclass時，<code>Object</code>為預設繼承的類別。<code>Object</code>也是繼承了<code>BasicObject</code></p></li>
</ul>


<h2>Objects</h2>

<ul>
<li>反正什麼東西在Ruby裡面都是Object，可以測試這些</li>
</ul>


<pre><code>-1.class
true.class
nil.class
/regex/.class
</code></pre>

<ul>
<li>如果puts出來，預設會用<code>to_s</code>轉換</li>
</ul>


<h2>eval</h2>

<pre><code>cmd = 'gets'
puts eval(cmd)
</code></pre>

<p><code>eval</code>可以像irb執行字串所代表的程式，這也是由Object繼承而來的函數</p>

<h2>public, private, protected</h2>

<p>三種屬性來控制method的曝露性</p>

<pre><code>class Method
  def public_method
    #預設為public，所有public method都可以呼叫
  end

  private # 在此之後方法都是private，只有在該instance內可以呼叫
  def private_method
  end
end
</code></pre>

<p>也可以這樣寫，不過我還沒看過實際有人這樣寫</p>

<pre><code>class Method
  def private_method
  end

  private :prviate_method #在這指定private_method屬性是private
</code></pre>

<ul>
<li><p>private內的方法繼承到subclass後，<strong>同樣可以呼叫</strong>，這跟在C++中不一樣</p></li>
<li><p>protected有夠難理解，原文是這樣的</p></li>
</ul>


<blockquote><p>Any instance of a class can call a protected method on any other instance of the class</p></blockquote>

<p>我是參考高見龍<a href="http://blog.eddie.com.tw/2011/07/26/public-protected-and-private-method-in-ruby/">這篇文章</a>才比較理解為什麼</p>

<p>可以在irb這樣測試</p>

<pre><code>class Base
  private 
  def private_show
    puts self.class
  end

  protected
  def protected_show
    puts self.class
  end
end
</code></pre>

<p>然後</p>

<pre><code>class SubBase &lt; Base
  def use_private
    private_show # 如果寫成self.private_show，會產生錯誤
  end

  def use_protected
    self.protected_show # 可以指定在self這個instance上
  end
end
</code></pre>

<ul>
<li><p>原生Ruby source code中，20萬行的程式碼，大約有1000個private methods, protected methods只有50幾個。意思就是用到的機會也不多啦。</p></li>
<li><p>另外Ruby也有個設計，如果你實在想突破限制使用class內的方法，可以用<code>send</code></p></li>
</ul>


<pre><code>sub_base.send(:private_show)
</code></pre>

<p>不過一般的作法大概都是另外寫一個public method把private method包起來給外部呼叫。</p>

<ul>
<li>public, private, protected並不是什麼特別的Ruby Magic，其實他們都是methods，呼叫後面帶參數</li>
</ul>


<p>相同的還有<code>require</code>載入檔案</p>

<pre><code>require 'rails_spec'
</code></pre>

<p>或者是<code>attr_accessor</code></p>

<pre><code>attr_accessor :name
</code></pre>

<p>然後我們就可以有<code>name</code>的getter和setter方法</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -6 [Use Symbols to Stand for Something]]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/03/eloquent-ruby-6/"/>
    <updated>2015-05-03T22:06:44+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/03/eloquent-ruby-6</id>
    <content type="html"><![CDATA[<h1>Chapter 6 - Use Symbols to Stand for Something</h1>

<p>String和Symbol很類似，都可以用來代表程式中的某個事物，但字串還多了可以被用來處理得到額外資訊，如果我們單純只是想要用來代表程式中的某個事物，用Symbol就可以了。</p>

<p>－ 同一個symbol永遠指著同一個物件，如</p>

<pre><code>a = :sym 
b= a
c = :sym
</code></pre>

<p>a, b, c都是相同的物件</p>

<p>但如果是string</p>

<pre><code>a = "sym"
b = "sym"
</code></pre>

<p><code>a.equal? b</code> 會回傳false</p>

<ul>
<li>所有Ruby的物件都有一個<code>public_methods</code>的函數，會回傳一個Array of symbols</li>
</ul>


<hr />

<p>簡單總結這章，Symbol因為有著unique, immutable這兩個特性，在用來當作代表性詞時就很實用，尤其是在應用hash時。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -5 [Find the Right String With Regular Expressions]]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/03/eloquent-ruby-5/"/>
    <updated>2015-05-03T20:38:53+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/03/eloquent-ruby-5</id>
    <content type="html"><![CDATA[<h1>Chapter 5 - Find the Right String with Regular Expressions</h1>

<h2>Match One Character</h2>

<ul>
<li><p><code>.</code>可以match任何單一字元(except new line)</p></li>
<li><p>如果想match <code>.</code>本身，可以用<code>\</code>，如<code>3\.14</code></p></li>
<li><p>再譬如<code>.r\.</code>，可以match <code>Mr.</code> or <code>Dr.</code></p></li>
</ul>


<h2>Sets, Range, Alternatives</h2>

<h3>Sets</h3>

<ul>
<li><p>例如<code>[0123456789]</code>可以match任何一個數字字元</p></li>
<li><p><code>[pPaA][Mm]</code>可以match <code>Am</code> or <code>pm</code>.</p></li>
</ul>


<h3>Range</h3>

<ul>
<li><p><code>[0-9a-f]</code>可以match任何一個16進位的字元</p></li>
<li><p><code>\d</code>可以match任何一個數字字元，<code>\d\d</code>可以match 連續2個數字字元</p></li>
<li><p><code>\w</code>可以match任何一個字元，包含數字、底線等</p></li>
<li><p><code>\s</code>可以match任何一個空白字元，包含space, tab, new line.</p></li>
</ul>


<h3>Alternatives</h3>

<ul>
<li><p><code>|</code>是替換符號</p></li>
<li><p><code>A\.M\.|AM|P\.M\.|PM</code> 可以match <code>A.M.</code> or <code>AM</code>, or <code>P.M.</code> or <code>PM</code></p></li>
<li><p>處理時間格式可以用 <code>\d\d:\d\d (AM|PM)</code></p></li>
</ul>


<h2>Asterist <code>*</code></h2>

<ul>
<li><p>*星號可以表示在星號前的字元有任意個，包含零個。</p></li>
<li><p><code>AB*</code>，可以match <code>AB</code>, <code>A</code>, or <code>ABBBB</code></p></li>
<li><p>所以可以用 <code>[0–9]*</code>，match任何長度的數字</p></li>
</ul>


<h2>Regular Expression in Ruby</h2>

<ul>
<li><p>Format regex by slash: <code>/\d\d:\d\d (AM|PM)/</code></p></li>
<li><p>use operator <code>=~</code></p></li>
<li><p>所以在irb中跑這段</p></li>
</ul>


<pre><code>/\d\d:\d\d (AM|PM)/ =~ '10:24 PM'
</code></pre>

<p>回傳<code>0</code>，這表示字串有符合，從index = 0的位置開始。</p>

<ul>
<li><p>如果沒有符合，回傳<code>nil</code></p></li>
<li><p>可以變成case insensitive，加上i，如：<code>/AM/i =~ 'am'</code></p></li>
<li><p>也可以當參數傳入gsub來用</p></li>
</ul>


<pre><code>time_string.gsub!( /\d\d:\d\d (AM|PM)/, '**:** **' )
</code></pre>

<h2>Beginning and Ending</h2>

<ul>
<li><p>如果想要match字串的開頭用指定的文字，可以加入<code>\A</code>，如<code>\AIn the Beginning</code>，可以match字串前面為<code>In the Beginning</code></p></li>
<li><p>反過來如果想要match字串結尾用指定的文字，可以在尾巴加入<code>\z</code></p></li>
<li><p>如果想要match字串中<code>任何一行的開頭</code>有滿足，可以在條件字串前面加上<code>^</code></p></li>
<li><p>如果想要match字串中<code>任何一行的結尾</code>有滿足，可以在條件字串尾巴加上<code>$</code></p></li>
<li><p>如果想要進階同時match開頭跟結尾</p></li>
</ul>


<pre><code>/^Once upon a time.*happily ever after\.$/
</code></pre>

<p>這樣會失敗，因為<code>.</code>配合<code>*</code>雖然可以取代中間的任意數量的字元，但<code>.</code>不包含new line</p>

<pre><code>/^Once upon a time.*happily ever after\.$/m
</code></pre>

<p>在結尾加上<code>m</code>可以關閉<code>.</code>這個特性。</p>

<ul>
<li><code>?</code>的作用和<code>*</code>類似</li>
</ul>

]]></content>
  </entry>
  
</feed>
