<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | The Life Alchemist]]></title>
  <link href="http://www.tomohung.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://www.tomohung.com/"/>
  <updated>2015-12-18T22:01:48+08:00</updated>
  <id>http://www.tomohung.com/</id>
  <author>
    <name><![CDATA[Tomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Interview Review After Tealeaf]]></title>
    <link href="http://www.tomohung.com/blog/2015/07/26/interview-review-after-tealeaf/"/>
    <updated>2015-07-26T07:07:25+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/07/26/interview-review-after-tealeaf</id>
    <content type="html"><![CDATA[<p>It&rsquo;s a late post since I got a Rails job for 2 month. I&rsquo;ll share my background and my interview experience, hope it will be helpful if you have the similar background like me.</p>

<p>Background:</p>

<ul>
<li>From Taiwan</li>
<li>Have 8 years for vision inspection machine development, it needs some of coding work by using C++.</li>
<li>But with NO any experience for web development.</li>
<li>Seek for a career change from a local-based develop a machine for manufacture industry to a cloud-based develop a user experience service.</li>
<li>Start Tealeaf course from last December Christmas and finish it in the early May. ( finish the course on schedule)</li>
<li>Start a Rails working on June.</li>
</ul>


<p>First, let me show the conclusion first:</p>

<ul>
<li>Join Tealeaf Academy is definitely worthy.</li>
<li>Finish the Interview Prep is definitely worthy.</li>
<li>Write blog for this course is definitely worthy.</li>
</ul>


<hr />

<p>Unfortunately, there&rsquo;re not too much job opportunities in Taiwan. This is true, but on the other hand, there are also not too much people really good at Rails. I mean, Rails is popular and well-known, but most people just finish some tutorials from free course like code school or some one day workshop like Rails girls. What we different is &ndash; this is a great opportunity to show your ambitious why you want to &ldquo;PAY&rdquo; for Tealeaf to upgrade your Rails skill. This is always the first question when I talk with interview officer.</p>

<p>I only got 4 interview chances in two month, two of them on April after finishing course 2 and the other two on May after finishing course 3. The Interview Prep is very very very helpful because I am asked for the exactly same questions from there!! Something like security probelm: csrf, authenticity token, or Rails architecture: MVC, OR Mapping, Ruby: polymorphism&hellip;etc. Even that example for association of person and children and grandson :-)</p>

<p>Doing Interview Prep is also a good chance to review what I knew and what I don&rsquo;t know. For example: n + 1 queries and eager loading.</p>

<p>Since I&rsquo;m not a native in English, so choosing a English-based course is also an impressing action. Same for writing blogs what I learned from Tealeaf course. I got an unexpecting interview chance from a foreigner company which offer higher payment than others, just because my blog is impressing to them.</p>

<hr />

<p>Hope these will be helpful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Many to Many Association With Two Join Tables]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/25/many-to-many-association-with-two-join-tables/"/>
    <updated>2015-05-25T21:37:28+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/25/many-to-many-association-with-two-join-tables</id>
    <content type="html"><![CDATA[<p>今天被問了一個問題當場答不出來，記錄起來，回家後試著實作看看</p>

<p>建立滿足以下關係的Table Associations</p>

<ol>
<li>User can create a tag for a book.</li>
<li>According to a given tag, return book list.</li>
<li>According to a given book, return tag list.</li>
</ol>


<p>提示：需要用到2個Join Table</p>

<p>以下作法不確定是否正確，閱讀時請斟酌</p>

<p>需要建立5個Table</p>

<pre><code class="ruby Users">class CreateUsers &lt; ActiveRecord::Migration
  def change
    create_table :users do |t|
      t.string :name
      t.timestamp
    end
  end
end
</code></pre>

<pre><code class="ruby Books">class CreateBooks &lt; ActiveRecord::Migration
  def change
    create_table :books do |t|
      t.string :title
      t.timestamps
    end
  end
end
</code></pre>

<pre><code class="ruby Tags">class CreateTags &lt; ActiveRecord::Migration
  def change
    create_table :tags do |t|
      t.text :label
      t.timestamps
    end
  end
end
</code></pre>

<pre><code class="ruby UserTags">class CreateUserTags &lt; ActiveRecord::Migration
  def change
    create_table :user_tags do |t|
      t.integer :user_id
      t.integer :tag_id
    end
  end
end
</code></pre>

<pre><code class="ruby BookTags">class CreateBookTags &lt; ActiveRecord::Migration
  def change
    create_table :book_tags do |t|
      t.integer :book_id
      t.integer :tag_id
    end
  end
end
</code></pre>

<p>接著是Model設定</p>

<pre><code class="ruby User">class User &lt; ActiveRecord::Base
  has_many :user_tags
  has_many :tags, through: :user_tags
end
</code></pre>

<pre><code class="ruby Book">class Book &lt; ActiveRecord::Base
  has_many :book_tags
  has_many :tags, through: :book_tags
end
</code></pre>

<pre><code class="ruby Tag">class Tag &lt; ActiveRecord::Base
  has_many :user_tags
  has_many :users, through: :user_tags

  has_many :book_tags
  has_many :books, through: :book_tags
end
</code></pre>

<pre><code class="ruby UserTag">class UserTag &lt; ActiveRecord::Base
  belongs_to :user
  belongs_to :tag
end
</code></pre>

<pre><code class="ruby BookTag">class BookTag &lt; ActiveRecord::Base
  belongs_to :book
  belongs_to :tag
end
</code></pre>

<p>然後在Rails Console下測試</p>

<pre><code class="ruby"># Create data
&gt; User.create(name: "Tomo")
&gt; Book.create(title: "Ruby")
&gt; Tag.create(label: "good book")
&gt; User.first.tags &lt;&lt; Tag.first
&gt; Book.first.tags &lt;&lt; Tag.first

# Test associations
&gt; User.first.tags # return tags belong to user
&gt; Book.first.tags # return tags belong to book
&gt; Tag.first.users # return tag's users
&gt; Tag.first.books # return tag's books
</code></pre>

<p>看起來都有正常連結，這個作法的缺點應該是在user_tags和book_tags都有記錄tag_id這個橍位，在空間上的利用效率較差。不過目前我也沒想到其它的方法就是了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week8 (2/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-2/"/>
    <updated>2015-05-07T15:43:10+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-2</id>
    <content type="html"><![CDATA[<h1>Handle Payments Failures</h1>

<p>Here we review what Jason Fried said in <a href="https://signalvnoise.com/posts/753-ask-37signals-how-do-you-process-credit-cards">How Do You Process Credit Card</a>:</p>

<blockquote><p>The one thing we’re often surprised by is how many accounts have charge issues so it’s important to really think about the error handling and customer experience issues related to declined cards.</p></blockquote>

<p>So there are thousands of reasons a credit card may become declined after user register our website. It&rsquo;s important to handle these payment failures.</p>

<p>Stripe also provide the test situation for us.</p>

<blockquote><p>Card Number: <code>4000000000000341</code><br/>
Description: <code>Attaching this card to a Customer object will succeed, but attempts to charge the customer will fail.</code></p></blockquote>

<p>This special card number will create a customer but charge will fail.</p>

<p>We may produce failed webhook event by Stripe Dashboard.</p>

<p>Open <code>Payments</code> on dashboard and click <code>Create Payment</code>, input the above invalid Card Number info and click Done. Then we can find a failure charge in <code>Events &amp; Webhooks</code>.</p>

<p>As the previous post, we can get failed data as <code>:event_data</code> for test:</p>

<pre><code class="ruby spec/requests/deactivate_user_with_payment_failure">describe 'customer on failed charge' do
  let(:event_data) do
    {
      "id" =&gt; "evt_15ycOeLCTUylKIRlJom1jayI",
      "created" =&gt; 1430718340,
      "livemode" =&gt; false,
      "type" =&gt; "charge.failed",
      "data" =&gt; {
        "object" =&gt; {
          "id" =&gt; "ch_15ycOdLCTUylKIRlq8G764Gc",
          "object" =&gt; "charge",
          "created" =&gt; 1430718339,
          "livemode" =&gt; false,
          "paid" =&gt; false,
          "status" =&gt; "failed",
          # .......
          "application_fee" =&gt; nil,
          "refunds" =&gt; {
            "object" =&gt; "list",
            "total_count" =&gt; 0,
            "has_more" =&gt; false,
            "url" =&gt; "/v1/charges/ch_15ycOdLCTUylKIRlq8G764Gc/refunds",
            "data" =&gt; []
          }
        }
      },
      "object" =&gt; "event",
      "pending_webhooks" =&gt; 1,
      "request" =&gt; "iar_6AyLkbPGvZltpn",
      "api_version" =&gt; "2015-04-07"
    }
  end
end
</code></pre>

<p>Notice that <code>:event_data</code> type is <code>charge.failed</code>.</p>

<p>Then we add event <code>charge.failed</code> in <code>strip.rb</code></p>

<pre><code class="ruby config/initializers/stripe.rb">StripeEvent.configure do |events|
  events.subscribe 'charge.failed' do |event|
    user = User.find_by(customer_token: event.data.object.customer)
    user.deactivate!
  end
end
</code></pre>

<p>We simplpy deactivate user here, usually, it should send a warning mail to the user.</p>

<p>Here is the request test:</p>

<pre><code class="ruby spec/requests/deactivate_user_with_payment_failure">describe 'customer on failed charge' do
  let(:event_data) do
    #...
  end

  it 'deactivates a user with the webhook data from stripe for charge failed', vcr: true do
    user = Fabricate(:user, customer_token: "cus_6Awy7ItkTK5HCv", active: true)
    post '/stripe_events', event_data
    expect(user.reload).not_to be_active
  end
end
</code></pre>

<p>We need to add column <code>active</code> for <code>User</code> to store the status.</p>

<pre><code class="ruby">add_column :users, :active, :boolean, default: true
</code></pre>

<p>Make the <code>active</code> column default is true, otherwise Rails will set <code>false</code> for default value.</p>

<h1>A Short Conclusion for Stripe</h1>

<p>We cover Stripe for last three weeks.</p>

<ul>
<li><p>In week 6, we introduce Stripe for charge. How to build a custom form to charge. And test by using <code>vcr</code> for replay response.</p></li>
<li><p>In week 7, we refactor code into <code>UserSignup</code>, as an <code>Service Object</code> of OOP concept. And we need to use javascript driver <code>webkit</code> and <code>selenium</code> in RSpec because of Stripe api.</p></li>
<li><p>In week 8, we use <code>Subscription</code> to charge monthly instead of charge once. And we handle events by <code>Webhook</code>, to deal with <code>charge.succeeded</code> and <code>charge.failed</code> events.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week8 (1/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-1/"/>
    <updated>2015-05-07T10:40:17+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-1</id>
    <content type="html"><![CDATA[<h1>Subscription</h1>

<p>This week it&rsquo;s still about Stripe. Last week, we use Stripe to charge once, and Stripe also offer us to charge  monthly. This is called <code>Subscription</code>.</p>

<p>First following the <a href="https://stripe.com/docs/subscriptions">instruction here</a> to set Plan.</p>

<p>Then write the test for <code>customer charge</code></p>

<pre><code class="ruby">describe StripeWrapper, vcr: true do
  describe "StripeWrapper::customer" do
    it 'create a customer with valid card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: valid_token, email: user.email)
      expect(charge).to be_success
    end

    it 'does not create a customer with declined card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: invalid_token, email: user.email)
      expect(charge).not_to be_success
    end

    it 'return error message with declined card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: invalid_token, email: user.email)
      expect(charge.error_message).to be_present
    end

    it 'returns the customer token for a valid card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: valid_token, email: user.email)
      expect(charge.customer_token).to be_present
    end
  end
end
</code></pre>

<p><code>StripeWrapper::Charge.customer</code> is written like this:</p>

<pre><code class="ruby models/stripe_wrapper.rb">module StripeWrapper
  class Charge
    attr_reader :response, :status

    def self.customer(options = {})    
      begin
        response = Stripe::Customer.create(
          source: options[:source],
          plan: "BASE",
          email: options[:email]
        )
        new(response, :success)
      rescue Stripe::CardError =&gt; e
        new(e, :error)
      end
    end
  end
end
</code></pre>

<p>Here is a tip, in Week7, since we merge code into <code>UserSignup</code> service object, although we change behavior from <code>charge</code> to <code>customer</code>, it&rsquo;s unrelated to <code>UsersControler#create</code> code.</p>

<pre><code class="ruby users_controller.rb">  #some code...
  user_signup_service = UserSignup.new(@user)
  result = user_signup_service.sign_up(params[:stripeToken], params[:token])
</code></pre>

<p>We only need to modified code in <code>UserSignup.sign_up</code>.</p>

<pre><code class="ruby services/user_signup.rb">  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        #do something...
      else
        #do something...
      end
    else
      #do something...
    end
  end

  def customer_charge_user_with_stripe(token)
    StripeWrapper::Charge.customer(
      source: token,
      email: @user.email
    )
  end
</code></pre>

<h1>Stripe Webhooks</h1>

<p>We can review Stripe payments on Stripe&rsquo;s dashboard, but what if we want to track and save these records in our website?</p>

<p>Here we instroduce <a href="https://stripe.com/docs/webhooks">Webhook</a></p>

<p>We need Stripe to trigger an event for our server, then we can hold response from Stripe into our database.</p>

<ol>
<li>Go <code>Account setting</code>-><code>Webhooks</code>-><code>Add endpoint...</code></li>
<li>Input your website url. &lt;- explain it later</li>
<li>Select test mode, and press Done</li>
<li>Click <code>Send test webhook</code></li>
</ol>


<p>For developement, we use <a href="http://requestb.in/">RequestBin</a> here to inspect HTTP requests.</p>

<p>Create a RequestBin Url for Stripe endpoint, from the link above, and input the url to Step 2. Click <code>Send test webhook</code> and go back refresh RequestBin page, you will see the response.</p>

<p>Instead of this, we also can review the response from Stripe <code>dashboard</code>-><code>Events &amp; Webhooks</code>, select one of record and check the <code>Webhook Details</code>.</p>

<p>Why we want to check response here? It&rsquo;s just prepared for test data.</p>

<p>For example, create a RSpec file for <code>succeeded payment</code>, and convert response to a fake data <code>:event_data</code></p>

<pre><code class="ruby ">describe "Create payment on successful charge" do
  let(:event_data) do
    {
      "id"=&gt; "evt_15yYzgLCTUylKIRln74HkdCq",
      "created"=&gt; 1430705260,
      "livemode"=&gt; false,
      "type"=&gt; "charge.succeeded",
      "data"=&gt; {
        "object"=&gt; {
          "id"=&gt; "ch_15yYzgLCTUylKIRlP66CKpX5",
          "object"=&gt; "charge",
          "created"=&gt; 1430705260,
          "livemode"=&gt; false,
          "paid"=&gt; true,
          "status"=&gt; "succeeded",
          "amount"=&gt; 99,
          "currency"=&gt; "usd",
          "refunded"=&gt; false,
          "source"=&gt; {
            "id"=&gt; "card_15yYzeLCTUylKIRll7zhkfMs",
            "object"=&gt; "card",
            #.........
            "dynamic_last4"=&gt; nil,
            "metadata"=&gt; {},
            "customer"=&gt; "cus_6Aupm1THLvHTnO"
          },
          "captured"=&gt; true,
          "balance_transaction"=&gt; "txn_15yYzgLCTUylKIRluBT7Obmz",
          "failure_message"=&gt; nil,
          "failure_code"=&gt; nil,
          "amount_refunded"=&gt; 0,
          "customer"=&gt; "cus_6Aupm1THLvHTnO",
          "invoice"=&gt; "in_15yYzgLCTUylKIRlcnjWhIBb",
          "application_fee"=&gt; nil,
          #..............
          "refunds"=&gt; {
            "object"=&gt; "list",
            "total_count"=&gt; 0,
            "has_more"=&gt; false,
            "url"=&gt; "/v1/charges/ch_15yYzgLCTUylKIRlP66CKpX5/refunds",
            "data"=&gt; []
          }
        }
      },
      "object"=&gt; "event",
      "pending_webhooks"=&gt; 1,
      "request"=&gt; "iar_6AupyN8zrE6fF4",
      "api_version"=&gt; "2015-04-07"
    }    
  end

  #some spec here...
end
</code></pre>

<p>According to the data, the event type is <code>charge.succeeded</code>.</p>

<p>In order to receive Stripe Webhook event, we need the gem <code>stripe_event</code></p>

<pre><code>gem 'stripe_event'
</code></pre>

<p>In config/routes.rb</p>

<pre><code>mount StripeEvent::Engine, at: '/stripe_events' # provide a custom path
</code></pre>

<p>Get mark here for the path <code>/stripe_events</code>, because it&rsquo;s the endpoint for setting webhook in Stripe&rsquo;s account setting. Create a webhook on Stripe, for example, my website is <code>https://tomo-myflix.herokuapp.com</code>, then endpoint url is <code>https://tomo-myflix.herokuapp.com/stripe_events</code></p>

<p>Then Stripe_Event help us to deal with stripe events here:</p>

<pre><code class="ruby config/initializers/stripe.rb">StripeEvent.configure do |events|
  events.subscribe 'charge.succeeded' do |event|
    user = User.find_by(customer_token: event.data.object.customer)
    Payment.create(user: user, amount: event.data.object.amount, reference_id: event.data.object.id)
  end
end
</code></pre>

<p><code>customer_token</code> is created when creating <code>User</code>. Add this column in <code>User</code> to track Stripe record. And code this in service object <code>UserSignup.sign_up</code>:</p>

<pre><code class="ruby models/user_signup.rb">#....
  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        @user.customer_token = charge.customer_token
        @user.save
# ....
</code></pre>

<p><code>customer_token</code> and <code>amount</code> can get from response <code>event.data.object</code>.</p>

<p>If your development follow the TDD process, here should code the test first like this</p>

<pre><code class="ruby spec/requests/create_payment_on_successful_charge_spec.rb">describe "Create payment on successful charge" do
  let(:event_data) do 
    # setting in above, ignore here.
  end

  it 'creates a payment with webhood from stripe for charge succeed', vcr: true do
    post '/stripe_events', event_data
    expect(Payment.count).to eq(1)
  end

  # other tests....
end  
</code></pre>

<p>Notice that we use <code>post '/stripe_events', event_data</code> to simulate Stripe emit a post to our server. So this is only for test to trigger StripeEvent in <code>initializers/stripe.rb</code>.</p>

<p>So far, we can create <code>Payment</code> by Stripe Webhook.</p>

<h1>ngrok for local test</h1>

<p>When we run the server on localhost, there is no way to let Stripe directly emit the post to our local machine. And we can use <code>ngrok</code> to do the response transfer.</p>

<p>Download <a href="https://ngrok.com/">ngrok</a> and install.</p>

<pre><code class="ruby">$ngrok 3000
</code></pre>

<p>Get an URL from ngrok, and set this url to Stripe Webhook endpoint. Run the rails server, and operate app by manual to check if payment record be saved.</p>

<p>Just a memo here, becuase I can&rsquo;t use ngrok on my Mac(looks like security problem). but it&rsquo;s ok because I test successful on Heroku.</p>

<p>The most important here is to set the app stirpe events URL in Stripe, for example my end point is:</p>

<pre><code>https://tomo-myflix.herokuapp.com/stripe_events
</code></pre>

<h1>ATDD for payment view</h1>

<p>The process for <code>admin views payment</code> is not very complex, so we can just write the spec outside-in, some also call this <code>ATDD</code>.</p>

<p>Here is a post talking about the <a href="http://gaboesquivel.com/blog/2014/differences-between-tdd-atdd-and-bdd/">differences between TDD, ATDD, BDD</a>.</p>

<pre><code class="ruby">feature 'Admin sees payments' do
  scenario 'admin can see payments' do
    user = Fabricate(:user)
    payment = Payment.create(user: user, reference_id: 'fake_reference_id', amount: 99)
    sign_in(Fabricate(:admin))
    visit admin_payments_path
    expect(page).to have_content("$0.99")
    expect(page).to have_content(user.email)
    expect(page).to have_content(user.full_name)
    expect(page).to have_content('fake_reference_id')
  end

  scenario 'user cannot see payments' do
    sign_in(Fabricate(:user))
    visit admin_payments_path
    expect(page).to have_content("You do not have access right.")
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (3/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3/"/>
    <updated>2015-05-06T17:22:47+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3</id>
    <content type="html"><![CDATA[<h1>Messsage Expectation</h1>

<p>We has metioned <a href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1/">Test Double at post (1/3)</a>, and here is another kind of Test Double, called <code>Mock Objects</code>.</p>

<blockquote><p>Assert communication, not response</p></blockquote>

<p>In previous post, we have moved the code into <code>UserSignup</code> services obejct and test it. And here all we need to test is ensure that <code>:sign_up</code> method is called in <code>UsersController#create</code>.</p>

<pre><code>describe UsersController do
  describe 'POST create' do
    context 'with valid input' do

      it 'should logged_in if create user' do
        result = double(:sign_up, successful?: true)
        expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)
        expect_any_instance_of(User).to receive(:id).and_return(1)
        post :create, user: Fabricate.attributes_for(:user)
        expect(session[:user_id]).to eq(1)
      end
    end
  end
end
</code></pre>

<p><code>expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)</code> is called <code>Message Expectation</code> in RSpec, a kind of <code>Mock Object</code>.</p>

<p>Refer to RSpec, it defines</p>

<blockquote><h3>Mock Objects and Test Stubs</h3>

<p>The names Mock Object and Test Stub suggest specialized Test Doubles. i.e. a Test Stub is a Test Double that only supports method stubs, and a Mock Object is a Test Double that supports message expectations and method stubs.</p>

<p>There is a lot of overlapping nomenclature here, and there are many variations of these patterns (fakes, spies, etc). Keep in mind that most of the time we&rsquo;re talking about method-level concepts that are variations of method stubs and message expectations, and we&rsquo;re applying to them to one generic kind of object: a Test Double.</p></blockquote>

<h1>Test Minimalist</h1>

<p>Here we got 3 resources of discussion test.</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=R9FOchgTtLM">Why you don&rsquo;t get mock objects</a> by Gregory</li>
<li><a href="http://martinfowler.com/articles/mocksArentStubs.html">Mock Aren&rsquo;t Stub</a> by Mark Folwer</li>
<li><a href="https://www.youtube.com/watch?v=URSWYvyc42M">The Magic tricks of Testing</a> by Sandi Mets</li>
</ul>


<p>Summary for these three resources.</p>

<p>I use Sandi&rsquo;s picture for the start:</p>

<p><img class="<a" src="href="http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png">http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png</a>&#8221;></p>

<p>Use this week assignment, class <code>UserSignup</code> for example:</p>

<ul>
<li><p>Incoming Query: We test UserSignup method <code>sign_up</code>, and expect it returns an successful object with valid info. This spec is testing this object state.</p></li>
<li><p>Incoming Command: We also test UserSignup method <code>sign_up</code>, and expect it should create an user with valid info. This is what Sandi said: side effects for outside.</p></li>
</ul>


<blockquote><p>Incoming Command and Incoming Query are all what Mark Folwer said State or Stub or Classical.</p></blockquote>

<ul>
<li><p>Sent to Self: According to Sandi&rsquo;s opinion, it&rsquo;s not necessary to test all private methods in class. Maybe for the complex method, we should think if we can abstract some logic into a new class, and give that class another tests if we need it.</p></li>
<li><p>Outgoing Query: Sandi ignore this, I guess she means that once the object send a new query to the other object, all we need to do is make sure that the other object works fine. And this should be test on that object, so we don&rsquo;t need to test outgoing query.</p></li>
<li><p>Outgoing Command: Once we let an object send a message to the other object do some side effects, all we need to do is make sure that this object do send a message. And this is method message expectation in RSpec, also Mark Folwer said behavior or Mockist or &lsquo;Mock&rsquo;.</p></li>
</ul>


<p>Gregory and Sandi all said that Mock Object can loose each objects association when testing. Once we are testing behavior( or maybe I can say testing interface), we don&rsquo;t need to bind the test and method with specific variable, but bind with an interface. It looks like apply OO concept on testing - try to loose connection with each objects, also loose each object&rsquo;s tests.</p>

<p>Kevin also metions this:</p>

<blockquote><p>a pure &ldquo;mockist&rdquo; way of doing test can be difficult in Rails apps, because in rails apps persistence is handled by the framework and for small apps most of object collaboration / message sending are about persistence. If you mock those interfaces, you end up mocking the guts of rails and that typically doesn&rsquo;t end up well.  this is also why we only touch this topic in the context of non rails objects like service objects.</p></blockquote>
]]></content>
  </entry>
  
</feed>
