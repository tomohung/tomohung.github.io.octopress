<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | The Life Alchemist]]></title>
  <link href="http://www.tomohung.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://www.tomohung.com/"/>
  <updated>2015-05-25T22:04:12+08:00</updated>
  <id>http://www.tomohung.com/</id>
  <author>
    <name><![CDATA[Tomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Many to Many Association With Two Join Tables]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/25/many-to-many-association-with-two-join-tables/"/>
    <updated>2015-05-25T21:37:28+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/25/many-to-many-association-with-two-join-tables</id>
    <content type="html"><![CDATA[<p>今天被問了一個問題當場答不出來，記錄起來</p>

<p>建立滿足以下關係的Table Associations
1. User can create a tag for a book.
2. According to a given tag, return book list.
3. According to a given book, return tag list.</p>

<p>提示：需要用到2個Join Table</p>

<p>以下作法不確定是否正確，閱讀時請斟酌</p>

<p>需要建立5個Table</p>

<pre><code class="ruby Users">class CreateUsers &lt; ActiveRecord::Migration
  def change
    create_table :users do |t|
      t.string :name
      t.timestamp
    end
  end
end
</code></pre>

<pre><code class="ruby Books">class CreateBooks &lt; ActiveRecord::Migration
  def change
    create_table :books do |t|
      t.string :title
      t.timestamps
    end
  end
end
</code></pre>

<pre><code class="ruby Tags">class CreateTags &lt; ActiveRecord::Migration
  def change
    create_table :tags do |t|
      t.text :label
      t.timestamps
    end
  end
end
</code></pre>

<pre><code class="ruby UserTags">class CreateUserTags &lt; ActiveRecord::Migration
  def change
    create_table :user_tags do |t|
      t.integer :user_id
      t.integer :tag_id
    end
  end
end
</code></pre>

<pre><code class="ruby BookTags">class CreateBookTags &lt; ActiveRecord::Migration
  def change
    create_table :book_tags do |t|
      t.integer :book_id
      t.integer :tag_id
    end
  end
end
</code></pre>

<p>接著是Model設定</p>

<pre><code class="ruby User">class User &lt; ActiveRecord::Base
  has_many :user_tags
  has_many :tags, through: :user_tags
end
</code></pre>

<pre><code class="ruby Book">class Book &lt; ActiveRecord::Base
  has_many :book_tags
  has_many :tags, through: :book_tags
end
</code></pre>

<pre><code class="ruby Tag">class Tag &lt; ActiveRecord::Base
  has_many :user_tags
  has_many :users, through: :user_tags

  has_many :book_tags
  has_many :books, through: :book_tags
end
</code></pre>

<pre><code class="ruby UserTag">class UserTag &lt; ActiveRecord::Base
  belongs_to :user
  belongs_to :tag
end
</code></pre>

<pre><code class="ruby BookTag">class BookTag &lt; ActiveRecord::Base
  belongs_to :book
  belongs_to :tag
end
</code></pre>

<p>然後在Rails Console下測試</p>

<pre><code class="ruby"># Create data
&gt; User.create(name: "Tomo")
&gt; Book.create(title: "Ruby")
&gt; Tag.create(label: "good book")
&gt; User.first.tags &lt;&lt; Tag.first
&gt; Book.first.tags &lt;&lt; Tag.first

# Test associations
&gt; User.first.tags # return tags belong to user
&gt; Book.first.tags # return tags belong to book
&gt; Tag.first.users # return tag's users
&gt; Tag.first.books # return tag's books
</code></pre>

<p>看起來都有正常連結，這個作法的缺點應該是在user_tags和book_tags都有記錄tag_id這個橍位，在空間上的利用效率較差。不過目前我也沒想到其它的方法就是了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week8 (2/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-2/"/>
    <updated>2015-05-07T15:43:10+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-2</id>
    <content type="html"><![CDATA[<h1>Handle Payments Failures</h1>

<p>Here we review what Jason Fried said in <a href="https://signalvnoise.com/posts/753-ask-37signals-how-do-you-process-credit-cards">How Do You Process Credit Card</a>:</p>

<blockquote><p>The one thing we’re often surprised by is how many accounts have charge issues so it’s important to really think about the error handling and customer experience issues related to declined cards.</p></blockquote>

<p>So there are thousands of reasons a credit card may become declined after user register our website. It&rsquo;s important to handle these payment failures.</p>

<p>Stripe also provide the test situation for us.</p>

<blockquote><p>Card Number: <code>4000000000000341</code><br/>
Description: <code>Attaching this card to a Customer object will succeed, but attempts to charge the customer will fail.</code></p></blockquote>

<p>This special card number will create a customer but charge will fail.</p>

<p>We may produce failed webhook event by Stripe Dashboard.</p>

<p>Open <code>Payments</code> on dashboard and click <code>Create Payment</code>, input the above invalid Card Number info and click Done. Then we can find a failure charge in <code>Events &amp; Webhooks</code>.</p>

<p>As the previous post, we can get failed data as <code>:event_data</code> for test:</p>

<pre><code class="ruby spec/requests/deactivate_user_with_payment_failure">describe 'customer on failed charge' do
  let(:event_data) do
    {
      "id" =&gt; "evt_15ycOeLCTUylKIRlJom1jayI",
      "created" =&gt; 1430718340,
      "livemode" =&gt; false,
      "type" =&gt; "charge.failed",
      "data" =&gt; {
        "object" =&gt; {
          "id" =&gt; "ch_15ycOdLCTUylKIRlq8G764Gc",
          "object" =&gt; "charge",
          "created" =&gt; 1430718339,
          "livemode" =&gt; false,
          "paid" =&gt; false,
          "status" =&gt; "failed",
          # .......
          "application_fee" =&gt; nil,
          "refunds" =&gt; {
            "object" =&gt; "list",
            "total_count" =&gt; 0,
            "has_more" =&gt; false,
            "url" =&gt; "/v1/charges/ch_15ycOdLCTUylKIRlq8G764Gc/refunds",
            "data" =&gt; []
          }
        }
      },
      "object" =&gt; "event",
      "pending_webhooks" =&gt; 1,
      "request" =&gt; "iar_6AyLkbPGvZltpn",
      "api_version" =&gt; "2015-04-07"
    }
  end
end
</code></pre>

<p>Notice that <code>:event_data</code> type is <code>charge.failed</code>.</p>

<p>Then we add event <code>charge.failed</code> in <code>strip.rb</code></p>

<pre><code class="ruby config/initializers/stripe.rb">StripeEvent.configure do |events|
  events.subscribe 'charge.failed' do |event|
    user = User.find_by(customer_token: event.data.object.customer)
    user.deactivate!
  end
end
</code></pre>

<p>We simplpy deactivate user here, usually, it should send a warning mail to the user.</p>

<p>Here is the request test:</p>

<pre><code class="ruby spec/requests/deactivate_user_with_payment_failure">describe 'customer on failed charge' do
  let(:event_data) do
    #...
  end

  it 'deactivates a user with the webhook data from stripe for charge failed', vcr: true do
    user = Fabricate(:user, customer_token: "cus_6Awy7ItkTK5HCv", active: true)
    post '/stripe_events', event_data
    expect(user.reload).not_to be_active
  end
end
</code></pre>

<p>We need to add column <code>active</code> for <code>User</code> to store the status.</p>

<pre><code class="ruby">add_column :users, :active, :boolean, default: true
</code></pre>

<p>Make the <code>active</code> column default is true, otherwise Rails will set <code>false</code> for default value.</p>

<h1>A Short Conclusion for Stripe</h1>

<p>We cover Stripe for last three weeks.</p>

<ul>
<li><p>In week 6, we introduce Stripe for charge. How to build a custom form to charge. And test by using <code>vcr</code> for replay response.</p></li>
<li><p>In week 7, we refactor code into <code>UserSignup</code>, as an <code>Service Object</code> of OOP concept. And we need to use javascript driver <code>webkit</code> and <code>selenium</code> in RSpec because of Stripe api.</p></li>
<li><p>In week 8, we use <code>Subscription</code> to charge monthly instead of charge once. And we handle events by <code>Webhook</code>, to deal with <code>charge.succeeded</code> and <code>charge.failed</code> events.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week8 (1/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-1/"/>
    <updated>2015-05-07T10:40:17+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/07/reflection-to-tealeaf-course3-week8-1</id>
    <content type="html"><![CDATA[<h1>Subscription</h1>

<p>This week it&rsquo;s still about Stripe. Last week, we use Stripe to charge once, and Stripe also offer us to charge  monthly. This is called <code>Subscription</code>.</p>

<p>First following the <a href="https://stripe.com/docs/subscriptions">instruction here</a> to set Plan.</p>

<p>Then write the test for <code>customer charge</code></p>

<pre><code class="ruby">describe StripeWrapper, vcr: true do
  describe "StripeWrapper::customer" do
    it 'create a customer with valid card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: valid_token, email: user.email)
      expect(charge).to be_success
    end

    it 'does not create a customer with declined card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: invalid_token, email: user.email)
      expect(charge).not_to be_success
    end

    it 'return error message with declined card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: invalid_token, email: user.email)
      expect(charge.error_message).to be_present
    end

    it 'returns the customer token for a valid card' do
      user = Fabricate(:user)
      charge = StripeWrapper::Charge.customer(source: valid_token, email: user.email)
      expect(charge.customer_token).to be_present
    end
  end
end
</code></pre>

<p><code>StripeWrapper::Charge.customer</code> is written like this:</p>

<pre><code class="ruby models/stripe_wrapper.rb">module StripeWrapper
  class Charge
    attr_reader :response, :status

    def self.customer(options = {})    
      begin
        response = Stripe::Customer.create(
          source: options[:source],
          plan: "BASE",
          email: options[:email]
        )
        new(response, :success)
      rescue Stripe::CardError =&gt; e
        new(e, :error)
      end
    end
  end
end
</code></pre>

<p>Here is a tip, in Week7, since we merge code into <code>UserSignup</code> service object, although we change behavior from <code>charge</code> to <code>customer</code>, it&rsquo;s unrelated to <code>UsersControler#create</code> code.</p>

<pre><code class="ruby users_controller.rb">  #some code...
  user_signup_service = UserSignup.new(@user)
  result = user_signup_service.sign_up(params[:stripeToken], params[:token])
</code></pre>

<p>We only need to modified code in <code>UserSignup.sign_up</code>.</p>

<pre><code class="ruby services/user_signup.rb">  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        #do something...
      else
        #do something...
      end
    else
      #do something...
    end
  end

  def customer_charge_user_with_stripe(token)
    StripeWrapper::Charge.customer(
      source: token,
      email: @user.email
    )
  end
</code></pre>

<h1>Stripe Webhooks</h1>

<p>We can review Stripe payments on Stripe&rsquo;s dashboard, but what if we want to track and save these records in our website?</p>

<p>Here we instroduce <a href="https://stripe.com/docs/webhooks">Webhook</a></p>

<p>We need Stripe to trigger an event for our server, then we can hold response from Stripe into our database.</p>

<ol>
<li>Go <code>Account setting</code>-><code>Webhooks</code>-><code>Add endpoint...</code></li>
<li>Input your website url. &lt;- explain it later</li>
<li>Select test mode, and press Done</li>
<li>Click <code>Send test webhook</code></li>
</ol>


<p>For developement, we use <a href="http://requestb.in/">RequestBin</a> here to inspect HTTP requests.</p>

<p>Create a RequestBin Url for Stripe endpoint, from the link above, and input the url to Step 2. Click <code>Send test webhook</code> and go back refresh RequestBin page, you will see the response.</p>

<p>Instead of this, we also can review the response from Stripe <code>dashboard</code>-><code>Events &amp; Webhooks</code>, select one of record and check the <code>Webhook Details</code>.</p>

<p>Why we want to check response here? It&rsquo;s just prepared for test data.</p>

<p>For example, create a RSpec file for <code>succeeded payment</code>, and convert response to a fake data <code>:event_data</code></p>

<pre><code class="ruby ">describe "Create payment on successful charge" do
  let(:event_data) do
    {
      "id"=&gt; "evt_15yYzgLCTUylKIRln74HkdCq",
      "created"=&gt; 1430705260,
      "livemode"=&gt; false,
      "type"=&gt; "charge.succeeded",
      "data"=&gt; {
        "object"=&gt; {
          "id"=&gt; "ch_15yYzgLCTUylKIRlP66CKpX5",
          "object"=&gt; "charge",
          "created"=&gt; 1430705260,
          "livemode"=&gt; false,
          "paid"=&gt; true,
          "status"=&gt; "succeeded",
          "amount"=&gt; 99,
          "currency"=&gt; "usd",
          "refunded"=&gt; false,
          "source"=&gt; {
            "id"=&gt; "card_15yYzeLCTUylKIRll7zhkfMs",
            "object"=&gt; "card",
            #.........
            "dynamic_last4"=&gt; nil,
            "metadata"=&gt; {},
            "customer"=&gt; "cus_6Aupm1THLvHTnO"
          },
          "captured"=&gt; true,
          "balance_transaction"=&gt; "txn_15yYzgLCTUylKIRluBT7Obmz",
          "failure_message"=&gt; nil,
          "failure_code"=&gt; nil,
          "amount_refunded"=&gt; 0,
          "customer"=&gt; "cus_6Aupm1THLvHTnO",
          "invoice"=&gt; "in_15yYzgLCTUylKIRlcnjWhIBb",
          "application_fee"=&gt; nil,
          #..............
          "refunds"=&gt; {
            "object"=&gt; "list",
            "total_count"=&gt; 0,
            "has_more"=&gt; false,
            "url"=&gt; "/v1/charges/ch_15yYzgLCTUylKIRlP66CKpX5/refunds",
            "data"=&gt; []
          }
        }
      },
      "object"=&gt; "event",
      "pending_webhooks"=&gt; 1,
      "request"=&gt; "iar_6AupyN8zrE6fF4",
      "api_version"=&gt; "2015-04-07"
    }    
  end

  #some spec here...
end
</code></pre>

<p>According to the data, the event type is <code>charge.succeeded</code>.</p>

<p>In order to receive Stripe Webhook event, we need the gem <code>stripe_event</code></p>

<pre><code>gem 'stripe_event'
</code></pre>

<p>In config/routes.rb</p>

<pre><code>mount StripeEvent::Engine, at: '/stripe_events' # provide a custom path
</code></pre>

<p>Get mark here for the path <code>/stripe_events</code>, because it&rsquo;s the endpoint for setting webhook in Stripe&rsquo;s account setting. Create a webhook on Stripe, for example, my website is <code>https://tomo-myflix.herokuapp.com</code>, then endpoint url is <code>https://tomo-myflix.herokuapp.com/stripe_events</code></p>

<p>Then Stripe_Event help us to deal with stripe events here:</p>

<pre><code class="ruby config/initializers/stripe.rb">StripeEvent.configure do |events|
  events.subscribe 'charge.succeeded' do |event|
    user = User.find_by(customer_token: event.data.object.customer)
    Payment.create(user: user, amount: event.data.object.amount, reference_id: event.data.object.id)
  end
end
</code></pre>

<p><code>customer_token</code> is created when creating <code>User</code>. Add this column in <code>User</code> to track Stripe record. And code this in service object <code>UserSignup.sign_up</code>:</p>

<pre><code class="ruby models/user_signup.rb">#....
  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        @user.customer_token = charge.customer_token
        @user.save
# ....
</code></pre>

<p><code>customer_token</code> and <code>amount</code> can get from response <code>event.data.object</code>.</p>

<p>If your development follow the TDD process, here should code the test first like this</p>

<pre><code class="ruby spec/requests/create_payment_on_successful_charge_spec.rb">describe "Create payment on successful charge" do
  let(:event_data) do 
    # setting in above, ignore here.
  end

  it 'creates a payment with webhood from stripe for charge succeed', vcr: true do
    post '/stripe_events', event_data
    expect(Payment.count).to eq(1)
  end

  # other tests....
end  
</code></pre>

<p>Notice that we use <code>post '/stripe_events', event_data</code> to simulate Stripe emit a post to our server. So this is only for test to trigger StripeEvent in <code>initializers/stripe.rb</code>.</p>

<p>So far, we can create <code>Payment</code> by Stripe Webhook.</p>

<h1>ngrok for local test</h1>

<p>When we run the server on localhost, there is no way to let Stripe directly emit the post to our local machine. And we can use <code>ngrok</code> to do the response transfer.</p>

<p>Download <a href="https://ngrok.com/">ngrok</a> and install.</p>

<pre><code class="ruby">$ngrok 3000
</code></pre>

<p>Get an URL from ngrok, and set this url to Stripe Webhook endpoint. Run the rails server, and operate app by manual to check if payment record be saved.</p>

<p>Just a memo here, becuase I can&rsquo;t use ngrok on my Mac(looks like security problem). but it&rsquo;s ok because I test successful on Heroku.</p>

<p>The most important here is to set the app stirpe events URL in Stripe, for example my end point is:</p>

<pre><code>https://tomo-myflix.herokuapp.com/stripe_events
</code></pre>

<h1>ATDD for payment view</h1>

<p>The process for <code>admin views payment</code> is not very complex, so we can just write the spec outside-in, some also call this <code>ATDD</code>.</p>

<p>Here is a post talking about the <a href="http://gaboesquivel.com/blog/2014/differences-between-tdd-atdd-and-bdd/">differences between TDD, ATDD, BDD</a>.</p>

<pre><code class="ruby">feature 'Admin sees payments' do
  scenario 'admin can see payments' do
    user = Fabricate(:user)
    payment = Payment.create(user: user, reference_id: 'fake_reference_id', amount: 99)
    sign_in(Fabricate(:admin))
    visit admin_payments_path
    expect(page).to have_content("$0.99")
    expect(page).to have_content(user.email)
    expect(page).to have_content(user.full_name)
    expect(page).to have_content('fake_reference_id')
  end

  scenario 'user cannot see payments' do
    sign_in(Fabricate(:user))
    visit admin_payments_path
    expect(page).to have_content("You do not have access right.")
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (3/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3/"/>
    <updated>2015-05-06T17:22:47+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3</id>
    <content type="html"><![CDATA[<h1>Messsage Expectation</h1>

<p>We has metioned <a href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1/">Test Double at post (1/3)</a>, and here is another kind of Test Double, called <code>Mock Objects</code>.</p>

<blockquote><p>Assert communication, not response</p></blockquote>

<p>In previous post, we have moved the code into <code>UserSignup</code> services obejct and test it. And here all we need to test is ensure that <code>:sign_up</code> method is called in <code>UsersController#create</code>.</p>

<pre><code>describe UsersController do
  describe 'POST create' do
    context 'with valid input' do

      it 'should logged_in if create user' do
        result = double(:sign_up, successful?: true)
        expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)
        expect_any_instance_of(User).to receive(:id).and_return(1)
        post :create, user: Fabricate.attributes_for(:user)
        expect(session[:user_id]).to eq(1)
      end
    end
  end
end
</code></pre>

<p><code>expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)</code> is called <code>Message Expectation</code> in RSpec, a kind of <code>Mock Object</code>.</p>

<p>Refer to RSpec, it defines</p>

<blockquote><h3>Mock Objects and Test Stubs</h3>

<p>The names Mock Object and Test Stub suggest specialized Test Doubles. i.e. a Test Stub is a Test Double that only supports method stubs, and a Mock Object is a Test Double that supports message expectations and method stubs.</p>

<p>There is a lot of overlapping nomenclature here, and there are many variations of these patterns (fakes, spies, etc). Keep in mind that most of the time we&rsquo;re talking about method-level concepts that are variations of method stubs and message expectations, and we&rsquo;re applying to them to one generic kind of object: a Test Double.</p></blockquote>

<h1>Test Minimalist</h1>

<p>Here we got 3 resources of discussion test.</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=R9FOchgTtLM">Why you don&rsquo;t get mock objects</a> by Gregory</li>
<li><a href="http://martinfowler.com/articles/mocksArentStubs.html">Mock Aren&rsquo;t Stub</a> by Mark Folwer</li>
<li><a href="https://www.youtube.com/watch?v=URSWYvyc42M">The Magic tricks of Testing</a> by Sandi Mets</li>
</ul>


<p>Summary for these three resources.</p>

<p>I use Sandi&rsquo;s picture for the start:</p>

<p><img class="<a" src="href="http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png">http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png</a>&#8221;></p>

<p>Use this week assignment, class <code>UserSignup</code> for example:</p>

<ul>
<li><p>Incoming Query: We test UserSignup method <code>sign_up</code>, and expect it returns an successful object with valid info. This spec is testing this object state.</p></li>
<li><p>Incoming Command: We also test UserSignup method <code>sign_up</code>, and expect it should create an user with valid info. This is what Sandi said: side effects for outside.</p></li>
</ul>


<blockquote><p>Incoming Command and Incoming Query are all what Mark Folwer said State or Stub or Classical.</p></blockquote>

<ul>
<li><p>Sent to Self: According to Sandi&rsquo;s opinion, it&rsquo;s not necessary to test all private methods in class. Maybe for the complex method, we should think if we can abstract some logic into a new class, and give that class another tests if we need it.</p></li>
<li><p>Outgoing Query: Sandi ignore this, I guess she means that once the object send a new query to the other object, all we need to do is make sure that the other object works fine. And this should be test on that object, so we don&rsquo;t need to test outgoing query.</p></li>
<li><p>Outgoing Command: Once we let an object send a message to the other object do some side effects, all we need to do is make sure that this object do send a message. And this is method message expectation in RSpec, also Mark Folwer said behavior or Mockist or &lsquo;Mock&rsquo;.</p></li>
</ul>


<p>Gregory and Sandi all said that Mock Object can loose each objects association when testing. Once we are testing behavior( or maybe I can say testing interface), we don&rsquo;t need to bind the test and method with specific variable, but bind with an interface. It looks like apply OO concept on testing - try to loose connection with each objects, also loose each object&rsquo;s tests.</p>

<p>Kevin also metions this:</p>

<blockquote><p>a pure &ldquo;mockist&rdquo; way of doing test can be difficult in Rails apps, because in rails apps persistence is handled by the framework and for small apps most of object collaboration / message sending are about persistence. If you mock those interfaces, you end up mocking the guts of rails and that typically doesn&rsquo;t end up well.  this is also why we only touch this topic in the context of non rails objects like service objects.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (2/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-2/"/>
    <updated>2015-05-06T15:42:37+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-2</id>
    <content type="html"><![CDATA[<h1>Beyond MVC</h1>

<p>Rails built on MVC (Model / View / Controller) structure. And something get complex if we got more code and logic. This is why we need design patterns.</p>

<h2>Decorators</h2>

<p>Some tips from gem <code>Draper</code>:</p>

<blockquote><p>Without Draper, this functionality might have been tangled up in procedural helpers or adding bulk to your models. With Draper decorators, you can wrap your models with presentation-related logic to organise - and test - this layer of your app much more effectively.</p></blockquote>

<p>Or</p>

<blockquote><p>Decorators are the ideal place to:</p>

<ul>
<li>format complex data for user display</li>
<li>define commonly-used representations of an object, like a <code>name</code> method that combine <code>first_name</code> and <code>last_name</code> attributes.</li>
<li>mark up attributes with a little semantic HTML, like turning a url fiedl into a hyperlink.</li>
</ul>
</blockquote>

<p>First, install gem</p>

<pre><code>gem 'draper'
</code></pre>

<pre><code class="ruby app/decorator/video_decorator.rb">class VideoDecorator &lt; Draper::Decorator
  delegate_all

  def rating
    "Rating: " + (object.rating.present? ? "#{object.rating}/5.0" : "NA")
  end
end
</code></pre>

<p>And use it in controller</p>

<pre><code class="ruby videos_controller.rb">  def show
    @video = VideoDecorator.decorate(Vidoe.find(params[:id]))
  dne
</code></pre>

<p>In view, just a clear line code.</p>

<pre><code class="ruby app/views/videos/show.html.haml">  = @video.rating
</code></pre>

<p>The key point here is that we have a model data (rating) associated with view, it&rsquo;s not suitable to put to <code>view helper</code> (some logic with model). That&rsquo;s why here using decorator to encapsulate presentation logic.</p>

<h2>Policy Objects</h2>

<p>Define what is premium user:</p>

<pre><code class="ruby models/user_level_policy.rb">class UserLevelPolicy
  attr_reader :user
  def initialize(user)
    @user = user
  end

  def premium?
    user.created_at &lt; Date.new(2010,1,1) || user.plan.premium?
  end
end
</code></pre>

<p>In Controller</p>

<pre><code class="ruby todo_controller.rb">###some code

  if UserLevelPolicy.new(current_user).premium?
    #do something
  else
    #do another thing
  end
</code></pre>

<p>Different with Decorators, Policy Ojbects only concern judgement logic into one place, without presentation concerned.</p>

<h2>Domain Objects</h2>

<p>if <code>User</code> has an attribute <code>credit_balance</code>. Then merge those code relative to <code>credit</code> into Domain Object.</p>

<pre><code class="ruby models/credit.rb">class Credit
  attr_accessor :credit_balance, :user

  def initialize(user)
    @credit_balance = user.current_credit_balance
    @user = user
  end

  def -(number)
    credit_balance = credit_balance - number
  end

  def save
    user.current_credit_balance = credit_balance
    user.save
  end

  def depleted?
    credit_balance &lt; 0
  end

  def low_balance?
    credit_balance &lt; 10
  end
end
</code></pre>

<p>Thus <code>Credit.new(current_user)</code> can call methods about credit, and don&rsquo;t need to put these code in model <code>User</code>, or <code>UsersController</code>.</p>

<h2>Service Objects</h2>

<p>We abstract an action as <code>sign up</code> in <code>UsersController#create</code>.</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def create    
    @user = User.new(user_params)
    user_signup_service = UserSignup.new(@user)
    result = user_signup_service.sign_up(params[:stripeToken], params[:token])

    if result.successful?
      session[:user_id] = @user.id
      redirect_to home_path
    else
      flash.now[:danger] =  user_signup_service.error_message
      render :new
    end
  end
end
</code></pre>

<p>Then create an service object <code>UserSignup</code> to handle this.</p>

<pre><code class="ruby app/service/user_signup.rb">class UserSignup

  attr_reader :error_message

  def initialize(user)
    @user = user
  end

  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        @user.customer_token = charge.customer_token
        @user.save
        set_invitation_following_relationship(invitation_token)
        AppMailer.delay.send_welcome_email(@user)
        @status = :success
        self
      else
        @status = :failed
        @error_message = charge.error_message
        self
      end
    else
      @status = :failed
      @error_message = "User info is invalid."
      self
    end
  end

  def successful?
    @status == :success
  end
end
</code></pre>

<p>There is an article from Code Climate <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models</a></p>

<p>As it metion when to use Service Object:</p>

<ul>
<li>The action is complex (e.g. closing the books at the end of an accounting period)</li>
<li>The action reaches across multiple models (e.g. an e-commerce purchase using Order, CreditCard and Customer objects)</li>
<li>The action interacts with an external service (e.g. posting to social networks)</li>
<li>The action is not a core concern of the underlying model (e.g. sweeping up outdated data after a certain time period).</li>
<li>There are multiple ways of performing the action (e.g. authenticating with an access token or password). This is the Gang of Four Strategy pattern.</li>
</ul>


<h2>Some Concept for Object Oriented Design</h2>

<ul>
<li><p><code>Fat model, skinny controllers</code> makes model uncontrollrable. That&rsquo;s why we need Object Oriented Design</p></li>
<li><p>YAGNI</p></li>
</ul>


<p>YAGNI means <code>You Aren't Gonna Need It!</code></p>

<p>Don&rsquo;t write the code you haven&rsquo;t need it.</p>

<p>Here is aother post talking about <code>YAGNI</code>, <code>KISS</code>, <code>DRY</code>.
<a href="http://www.itexico.com/blog/bid/99765/Software-Development-KISS-YAGNI-DRY-3-Principles-to-simplify-your-life">Software Development: KISS, YAGNI &amp; DRY. 3 Principles to simplify your life.</a></p>
]]></content>
  </entry>
  
</feed>
