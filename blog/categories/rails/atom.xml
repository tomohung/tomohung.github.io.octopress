<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | The Life Alchemist]]></title>
  <link href="http://www.tomohung.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://www.tomohung.com/"/>
  <updated>2015-05-07T07:05:09+08:00</updated>
  <id>http://www.tomohung.com/</id>
  <author>
    <name><![CDATA[Tomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (3/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3/"/>
    <updated>2015-05-06T17:22:47+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-3-slash-3</id>
    <content type="html"><![CDATA[<h1>Messsage Expectation</h1>

<p>We has metioned <a href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1/">Test Double at post (1/3)</a>, and here is another kind of Test Double, called <code>Mock Objects</code>.</p>

<blockquote><p>Assert communication, not response</p></blockquote>

<p>In previous post, we have moved the code into <code>UserSignup</code> services obejct and test it. And here all we need to test is ensure that <code>:sign_up</code> method is called in <code>UsersController#create</code>.</p>

<pre><code>describe UsersController do
  describe 'POST create' do
    context 'with valid input' do

      it 'should logged_in if create user' do
        result = double(:sign_up, successful?: true)
        expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)
        expect_any_instance_of(User).to receive(:id).and_return(1)
        post :create, user: Fabricate.attributes_for(:user)
        expect(session[:user_id]).to eq(1)
      end
    end
  end
end
</code></pre>

<p><code>expect_any_instance_of(UserSignup).to receive(:sign_up).and_return(result)</code> is called <code>Message Expectation</code> in RSpec, a kind of <code>Mock Object</code>.</p>

<p>Refer to RSpec, it defines</p>

<blockquote><h3>Mock Objects and Test Stubs</h3>

<p>The names Mock Object and Test Stub suggest specialized Test Doubles. i.e. a Test Stub is a Test Double that only supports method stubs, and a Mock Object is a Test Double that supports message expectations and method stubs.</p>

<p>There is a lot of overlapping nomenclature here, and there are many variations of these patterns (fakes, spies, etc). Keep in mind that most of the time we&rsquo;re talking about method-level concepts that are variations of method stubs and message expectations, and we&rsquo;re applying to them to one generic kind of object: a Test Double.</p></blockquote>

<h1>Test Minimalist</h1>

<p>Here we got 3 resources of discussion test.</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=R9FOchgTtLM">Why you don&rsquo;t get mock objects</a> by Gregory</li>
<li><a href="http://martinfowler.com/articles/mocksArentStubs.html">Mock Aren&rsquo;t Stub</a> by Mark Folwer</li>
<li><a href="https://www.youtube.com/watch?v=URSWYvyc42M">The Magic tricks of Testing</a> by Sandi Mets</li>
</ul>


<p>Summary for these three resources.</p>

<p>I use Sandi&rsquo;s picture for the start:</p>

<p><img class="<a" src="href="http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png">http://jnoconor.github.io/images/unit-testing-chart-sandi-metz.png</a>&#8221;></p>

<p>Use this week assignment, class <code>UserSignup</code> for example:</p>

<ul>
<li><p>Incoming Query: We test UserSignup method <code>sign_up</code>, and expect it returns an successful object with valid info. This spec is testing this object state.</p></li>
<li><p>Incoming Command: We also test UserSignup method <code>sign_up</code>, and expect it should create an user with valid info. This is what Sandi said: side effects for outside.</p></li>
</ul>


<blockquote><p>Incoming Command and Incoming Query are all what Mark Folwer said State or Stub or Classical.</p></blockquote>

<ul>
<li><p>Sent to Self: According to Sandi&rsquo;s opinion, it&rsquo;s not necessary to test all private methods in class. Maybe for the complex method, we should think if we can abstract some logic into a new class, and give that class another tests if we need it.</p></li>
<li><p>Outgoing Query: Sandi ignore this, I guess she means that once the object send a new query to the other object, all we need to do is make sure that the other object works fine. And this should be test on that object, so we don&rsquo;t need to test outgoing query.</p></li>
<li><p>Outgoing Command: Once we let an object send a message to the other object do some side effects, all we need to do is make sure that this object do send a message. And this is method message expectation in RSpec, also Mark Folwer said behavior or Mockist or &lsquo;Mock&rsquo;.</p></li>
</ul>


<p>Gregory and Sandi all said that Mock Object can loose each objects association when testing. Once we are testing behavior( or maybe I can say testing interface), we don&rsquo;t need to bind the test and method with specific variable, but bind with an interface. It looks like apply OO concept on testing - try to loose connection with each objects, also loose each object&rsquo;s tests.</p>

<p>Kevin also metions this:</p>

<blockquote><p>a pure &ldquo;mockist&rdquo; way of doing test can be difficult in Rails apps, because in rails apps persistence is handled by the framework and for small apps most of object collaboration / message sending are about persistence. If you mock those interfaces, you end up mocking the guts of rails and that typically doesn&rsquo;t end up well.  this is also why we only touch this topic in the context of non rails objects like service objects.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (2/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-2/"/>
    <updated>2015-05-06T15:42:37+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-2</id>
    <content type="html"><![CDATA[<h1>Beyond MVC</h1>

<p>Rails built on MVC (Model / View / Controller) structure. And something get complex if we got more code and logic. This is why we need design patterns.</p>

<h2>Decorators</h2>

<p>Some tips from gem <code>Draper</code>:</p>

<blockquote><p>Without Draper, this functionality might have been tangled up in procedural helpers or adding bulk to your models. With Draper decorators, you can wrap your models with presentation-related logic to organise - and test - this layer of your app much more effectively.</p></blockquote>

<p>Or</p>

<blockquote><p>Decorators are the ideal place to:</p>

<ul>
<li>format complex data for user display</li>
<li>define commonly-used representations of an object, like a <code>name</code> method that combine <code>first_name</code> and <code>last_name</code> attributes.</li>
<li>mark up attributes with a little semantic HTML, like turning a url fiedl into a hyperlink.</li>
</ul>
</blockquote>

<p>First, install gem</p>

<pre><code>gem 'draper'
</code></pre>

<pre><code class="ruby app/decorator/video_decorator.rb">class VideoDecorator &lt; Draper::Decorator
  delegate_all

  def rating
    "Rating: " + (object.rating.present? ? "#{object.rating}/5.0" : "NA")
  end
end
</code></pre>

<p>And use it in controller</p>

<pre><code class="ruby videos_controller.rb">  def show
    @video = VideoDecorator.decorate(Vidoe.find(params[:id]))
  dne
</code></pre>

<p>In view, just a clear line code.</p>

<pre><code class="ruby app/views/videos/show.html.haml">  = @video.rating
</code></pre>

<p>The key point here is that we have a model data (rating) associated with view, it&rsquo;s not suitable to put to <code>view helper</code> (some logic with model). That&rsquo;s why here using decorator to encapsulate presentation logic.</p>

<h2>Policy Objects</h2>

<p>Define what is premium user:</p>

<pre><code class="ruby models/user_level_policy.rb">class UserLevelPolicy
  attr_reader :user
  def initialize(user)
    @user = user
  end

  def premium?
    user.created_at &lt; Date.new(2010,1,1) || user.plan.premium?
  end
end
</code></pre>

<p>In Controller</p>

<pre><code class="ruby todo_controller.rb">###some code

  if UserLevelPolicy.new(current_user).premium?
    #do something
  else
    #do another thing
  end
</code></pre>

<p>Different with Decorators, Policy Ojbects only concern judgement logic into one place, without presentation concerned.</p>

<h2>Domain Objects</h2>

<p>if <code>User</code> has an attribute <code>credit_balance</code>. Then merge those code relative to <code>credit</code> into Domain Object.</p>

<pre><code class="ruby models/credit.rb">class Credit
  attr_accessor :credit_balance, :user

  def initialize(user)
    @credit_balance = user.current_credit_balance
    @user = user
  end

  def -(number)
    credit_balance = credit_balance - number
  end

  def save
    user.current_credit_balance = credit_balance
    user.save
  end

  def depleted?
    credit_balance &lt; 0
  end

  def low_balance?
    credit_balance &lt; 10
  end
end
</code></pre>

<p>Thus <code>Credit.new(current_user)</code> can call methods about credit, and don&rsquo;t need to put these code in model <code>User</code>, or <code>UsersController</code>.</p>

<h2>Service Objects</h2>

<p>We abstract an action as <code>sign up</code> in <code>UsersController#create</code>.</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def create    
    @user = User.new(user_params)
    user_signup_service = UserSignup.new(@user)
    result = user_signup_service.sign_up(params[:stripeToken], params[:token])

    if result.successful?
      session[:user_id] = @user.id
      redirect_to home_path
    else
      flash.now[:danger] =  user_signup_service.error_message
      render :new
    end
  end
end
</code></pre>

<p>Then create an service object <code>UserSignup</code> to handle this.</p>

<pre><code class="ruby app/service/user_signup.rb">class UserSignup

  attr_reader :error_message

  def initialize(user)
    @user = user
  end

  def sign_up(stripe_token = nil, invitation_token = nil)
    if @user.valid?      
      charge = customer_charge_user_with_stripe(stripe_token)
      if charge.success?
        @user.customer_token = charge.customer_token
        @user.save
        set_invitation_following_relationship(invitation_token)
        AppMailer.delay.send_welcome_email(@user)
        @status = :success
        self
      else
        @status = :failed
        @error_message = charge.error_message
        self
      end
    else
      @status = :failed
      @error_message = "User info is invalid."
      self
    end
  end

  def successful?
    @status == :success
  end
end
</code></pre>

<p>There is an article from Code Climate <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models</a></p>

<p>As it metion when to use Service Object:</p>

<ul>
<li>The action is complex (e.g. closing the books at the end of an accounting period)</li>
<li>The action reaches across multiple models (e.g. an e-commerce purchase using Order, CreditCard and Customer objects)</li>
<li>The action interacts with an external service (e.g. posting to social networks)</li>
<li>The action is not a core concern of the underlying model (e.g. sweeping up outdated data after a certain time period).</li>
<li>There are multiple ways of performing the action (e.g. authenticating with an access token or password). This is the Gang of Four Strategy pattern.</li>
</ul>


<h2>Some Concept for Object Oriented Design</h2>

<ul>
<li><p><code>Fat model, skinny controllers</code> makes model uncontrollrable. That&rsquo;s why we need Object Oriented Design</p></li>
<li><p>YAGNI</p></li>
</ul>


<p>YAGNI means <code>You Aren't Gonna Need It!</code></p>

<p>Don&rsquo;t write the code you haven&rsquo;t need it.</p>

<p>Here is aother post talking about <code>YAGNI</code>, <code>KISS</code>, <code>DRY</code>.
<a href="http://www.itexico.com/blog/bid/99765/Software-Development-KISS-YAGNI-DRY-3-Principles-to-simplify-your-life">Software Development: KISS, YAGNI &amp; DRY. 3 Principles to simplify your life.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week7 (1/3)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1/"/>
    <updated>2015-05-06T14:20:15+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week7-1</id>
    <content type="html"><![CDATA[<p>Last week, we use Stripe for charge in UsersController#create, it&rsquo;s a bit little complex code here. We need to wrap it.</p>

<p>Why we need to wrap it into a class:</p>

<ol>
<li><p>Easy to maintain code, isolate controller&rsquo;s and business logic. Remember we knew that <code>fat models, thin controllers</code>, here is a step further concept, we encapsulate code into <code>models/stripe_wrapper.rb</code></p></li>
<li><p>Easy to test, isolate test between different object is always a good idea.</p></li>
</ol>


<h1>How to Wrap</h1>

<p>For <code>module StripeWrapper</code> is just a namespace. Then we sort the code in UsersController#create,</p>

<pre><code>module StripeWrapper
  class Charge
    attr_reader :response, :status

    def initialize(response, status)
      @response = response
      @status = status
    end

    def self.create(options = {})      
      begin
        response = Stripe::Charge.create(
          amount: options[:amount], # amount in cents, again
          currency: "usd",
          source: options[:source],
          description: options[:description]
        )
        new(response, :success)
      rescue Stripe::CardError =&gt; e
        new(e, :error)
      end
    end

    def success?
      status == :success
    end

    def error_message
      response.message
    end
  end

  def self.set_api_key
    Stripe.api_key = ENV["STRIPE_SECRET_KEY"]
  end
end
</code></pre>

<p>Then we can call method <code>StripeWrapper::Charge(options)</code>.</p>

<p><code>new(repose, :sucess)</code> and <code>new(e, :error)</code> return an <code>StripeWrapper::Charge</code> object result.</p>

<h1>How to Test StripeWrapper</h1>

<p>Test return object <code>charge</code>:</p>

<pre><code>describe StripeWrapper do
  describe StripeWrapper::Charge do
    it 'makes successful charge' do
      charge = StripeWrapper::Charge.create(amount: 100, source: valid_token)
      expect(charge.response.amount).to eq(100)
      expect(charge.response.currency).to eq('usd')
      expect(charge).to be_success
    end
  end
end
</code></pre>

<p>But there is a problem, everytime we test, it will send a request to Stripe server. We don&rsquo;t want to do this and want to reduce test consumer time, use gem <code>vcr</code>.</p>

<pre><code>$ gem install vcr
$ gem install webmock
</code></pre>

<p>Then add <code>vcr: true</code> to spec</p>

<pre><code>it 'make successful charge', vcr: true do
  #something
end
</code></pre>

<p>vcr will record the reponse in <code>spec/cassettes</code>, when next time it find that test emit the same request again, it will not send the request outside to the server, but replaying saved response.</p>

<p>Here is vcr setting:</p>

<pre><code class="ruby spec_helper.rb">require 'vcr'

VCR.configure do |c|
  c.cassette_library_dir = 'spec/cassettes'
  c.hook_into :webmock
  c.configure_rspec_metadata!
  c.ignore_localhost = true
end
</code></pre>

<h1>How to test Controller#create</h1>

<p>Since we have test StripeWrapper, we don&rsquo;t want to test it again in Controller, or hit the Stripe server again. Use <a href="http://en.wikipedia.org/wiki/Test_double">Test Double</a> <code>stub</code> here.</p>

<p>For example, if we have a <code>PaymentController</code>:</p>

<pre><code>describe PaymentController do
  describe 'POST create' do
    it 'sets the flash success message' do
      charge = double("charge")
      charge.stub(:successful?).and_return(true)
      StripeWrapper::Charge.stub(:create).and_return(charge)
      post :create, token: "fake_token"
      expect(flash[:success]).to be_present
    end
  end
end
</code></pre>

<ol>
<li>Create a test stub <code>charge</code>, and stub a method <code>successful?</code> and return <code>true</code>.</li>
<li>stub <code>:create</code> method to <code>StripeWrapper::Charge</code> and return <code>charge</code>.</li>
</ol>


<p>Now we strike <code>post :create</code>, in PaymentController#create when running to code StripeWrapper::Charge, it will return a result <code>charge</code> with <code>charge.successful?</code> is <code>true</code>.</p>

<p>We do this is because make this controller#create test itself independently, and all we need to do is set StripeWrapper return successful.</p>

<blockquote><p>StripeWrapper will make a HTTP request, we can use <code>vcr</code> to record this, but it&rsquo;s not necessary becuase this test is already done in stripe_wrapper_spec. So here we choose to use <code>stub</code>.</p></blockquote>

<h1>How to do Feature Test with JavaScript</h1>

<p>Since we use javascript in view form, we need to turn on <code>:js</code></p>

<pre><code>feature 'visitor make payment' do
  scenario 'with valid card number', js: true do
    visit new_payment_path
    fill_in "Credit Card Number", with "424242424242424242"
    fill_in "Security Code", with "123"
    select "3 - March", form: "date_month"
    select "2015", from: "date_year"
    click_button "Submit Payment"

    expect(page).to have_content "Successful charge."
  end
end
</code></pre>

<p>Install gem</p>

<pre><code>gem 'selenium-webdriver'
gem 'capybara-webkit'
</code></pre>

<p>And set in <code>spec_helper.rb</code></p>

<pre><code class="ruby">Capybara.javascript_driver = :webkit # For default javascript server
Capybara.server_port = 52662 # For Selenium
</code></pre>

<p><code>webkit</code> is offered by <code>Qt</code> framework, it&rsquo;s faster than <code>Selenium</code> and invisible. <code>Selenium</code> process is visible, so it&rsquo;s suit for debug.</p>

<p>Careful when test in Email Invitation, I need to use <code>Selenium</code> instead of <code>webkit</code>, otherwise the test will be failed.</p>

<pre><code>scenario 'User successfully invites friend and invitation is accepted', {js: true, vcr: true, driver: :selenium} do
</code></pre>

<h2>Setting <a href="https://github.com/DatabaseCleaner/database_cleaner">database_cleaner</a></h2>

<p>It will lead a problem when we run javascript test, refer from RSpec doc:</p>

<blockquote><p>drivers which run the server in a different thread may not share the same transaction as your tests, causing data not to be shared between your test and test server.</p></blockquote>

<p>The problem is when running javascript, activerecord may delete database before javascript test finish.</p>

<p>We can use <code>database_cleaner</code> to do <code>truncation</code> instead of <code>transaction</code>. Manual create and destroy records.</p>

<pre><code>RSpec.configure do |config|
  config.use_transactional_fixtures = false

  config.before(:suite) do
    DatabaseCleaner.clean_with(:truncation)
  end

  config.before(:each) do
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each, :js =&gt; true) do
    DatabaseCleaner.strategy = :truncation
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week6 (2/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week6-2-slash-2/"/>
    <updated>2015-05-06T09:50:50+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week6-2-slash-2</id>
    <content type="html"><![CDATA[<p>These week we have two main part: <a href="https://github.com/carrierwaveuploader/carrierwave">CarrierWave</a> for uploading images as an admin, <a href="http://stripe.com">Stripe</a> for payments</p>

<p>The first part about CarrierWave for uploading images as an Admin is <a href="http://tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week6/">here</a>.</p>

<h1>Stripe for Payments</h1>

<p>Two articles about payments:</p>

<ul>
<li><a href="https://signalvnoise.com/posts/753-ask-37signals-how-do-you-process-credit-cards">How Do You Process Credit Card</a> by Jason Fried</li>
</ul>


<blockquote><p>The one thing we’re often surprised by is how many accounts have charge issues so it’s important to really think about the error handling and customer experience issues related to declined cards.</p></blockquote>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard">Payment Card Industry Data Security Standard by wiki</a></li>
</ul>


<h3>Stripe &amp; Figaro</h3>

<pre><code>gem 'stripe'
gem 'figaro'
</code></pre>

<p><code>$ figaro install</code></p>

<p>Use Figaro to set Environment variables, Do Not hard code it!!</p>

<pre><code>#config/application.yaml
test:
  STRIPE_SECRET_KEY: sk_test_xxxxxxxxx
  STRIPE_PUBLISHABLE_KEY: pk_test_xxxxxxxxxx

development:
  STRIPE_SECRET_KEY: sk_test_xxxxxxx
  STRIPE_PUBLISHABLE_KEY: pk_test_xxxxxxx

production:
  STRIPE_SECRET_KEY: sk_live_xxxxxx
  STRIPE_PUBLISHABLE_KEY: pk_live_xxxxxxxx
</code></pre>

<blockquote><p>If Stripe account doesn&rsquo;t activate, we only can use test key <code>sk_test_xxxxxxx</code> even ENV = production</p></blockquote>

<p>I also add this file <code>config/initailizers/figaro.rb</code></p>

<pre><code>Figaro.require_keys("STRIPE_SECRET_KEY", "STRIPE_PUBLISHABLE_KEY")
</code></pre>

<p>It&rsquo;s convenient to check if you forget to set Environment variables on deploy machine(ex. Circle CI or Heroku).</p>

<p>Figaro also provide a way to set Heroku ENV.</p>

<p><code>$ figaro heroku:set -e production</code></p>

<h3>Stripe Custom Form</h3>

<ol>
<li>Setting form view</li>
</ol>


<p>&#8220;`</p>

<script type="text/javascript" src="https://js.stripe.com/v2/"></script>




<script type="text/javascript">
Stripe.setPublishableKey("#{ENV['STRIPE_PUBLISHABLE_KEY']}");
</script>


<p>= javascript_include_tag &lsquo;payment&rsquo;</p>

<pre><code>
&gt; When deploy to Heroku, I got this error `Failed to load resource: the server responded with a status of 404 (Not Found)`

&gt; This is becuase assets pipeline, add this to the file
</code></pre>

<p>Rails.application.config.assets.precompile += [&lsquo;payment.js&rsquo;]
&#8220;`</p>

<p>Key Points:</p>

<ul>
<li>use <code>id: 'payment-form'</code> in form_form, this is corespond to <code>assets/javascripts/payment.js</code> content.</li>
<li>use <code>for</code> and <code>id</code> to connect label and input</li>
<li><code>data-stripe = "number"</code> and <code>data-stripe="cvc"</code></li>
<li><code>data: { stripe: "exp-yaer"}</code> and <code>data: { stripe: "exp-month"}</code></li>
</ul>


<p>Attributes of <code>data-stripe</code> is for Stripe to know credit infomation.</p>

<p>Then in our custom form:</p>

<pre><code class="haml">%section.register.container
  .row
    .col-sm-10.col-sm-offset-1
      = bootstrap_form_for @user, layout: :horizontal, html: {id: 'payment-form'} do |f|
        %header
          %h1 Register
        %fieldset
          = f.email_field :email, label: "Email Address"
          = f.password_field :password
          = f.text_field :full_name, label: 'Full Name'
          = hidden_field_tag :token, @invitation_token
        %fieldset.credit_card
          %span.payment-errors
          .form-group
            %label.control-label.col-sm-2(for="credit_card_number") Credit Card Number
            .col-sm-6
              %input.form-control(type="text" data-stripe="number" id="credit_card_number")
          .form-group
            %label.control-label.col-sm-2(for="security_code") Security Code
            .col-sm-6
              %input.form-control(type="text" data-stripe="cvc" id="security_code")
          .form-group
            %label.control-label.col-sm-2 Expiration
            .col-sm-3
              = select_month(Date.today, {add_month_numbers: true},  class: 'form-control', data: { stripe: "exp-month"})
            .col-sm-2
              = select_year(Date.today.year, {start_year: Date.today.year, end_year: Date.today.year + 4}, class: 'form-control', data: { stripe: "exp-year"} )
        %fieldset.actions.control-group.col-sm-offset-2
          .controls
            %input(type="submit" value="Sign Up" class="btn btn-default")
</code></pre>

<h3>Setting in Controller Action</h3>

<pre><code># Set your secret key: remember to change this to your live secret key in production
# See your keys here https://dashboard.stripe.com/account/apikeys
Stripe.api_key = "sk_test_yNosIrCvrAuVttjO60dxy7zy"

# Get the credit card details submitted by the form
token = params[:stripeToken]

# Create the charge on Stripe's servers - this will charge the user's card
begin
  charge = Stripe::Charge.create(
    :amount =&gt; 1000, # amount in cents, again
    :currency =&gt; "usd",
    :source =&gt; token,
    :description =&gt; "Example charge"
  )
rescue Stripe::CardError =&gt; e
  # The card has been declined
end
</code></pre>

<p>Now we click submit button, charge will be deliever to Stripe.</p>

<blockquote><p>Notice again, don&rsquo;t foget to set ENV on Circle CI or Heroku if you deploy code to there.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflection to Tealeaf Course3 Week6 (1/2)]]></title>
    <link href="http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week6/"/>
    <updated>2015-05-06T08:57:30+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/05/06/reflection-to-tealeaf-course3-week6</id>
    <content type="html"><![CDATA[<p>These week we have two main part: <a href="https://github.com/carrierwaveuploader/carrierwave">CarrierWave</a> for uploading images as an admin, <a href="http://stripe.com">Stripe</a> for payments</p>

<h1>CarrierWave for uploading images as an Admin</h1>

<h3>Admin</h3>

<p>In order to controll user is a admin or not, the best practice is to build a admin its own self routes and controllers.</p>

<p>In <code>routes.rb</code></p>

<pre><code>namespace :admin do
  resources :todos, only: [:index, :destroy]
end
</code></pre>

<p>Then <code>rake routes</code>, we got</p>

<pre><code>admin_todos  admin/todos  admin/todos#index
</code></pre>

<p>Build the controller file in the path: <code>/controllers/admin/todos_controller.rb</code></p>

<pre><code>class Admin::TodosController &lt; ApplicationController
end
</code></pre>

<blockquote><p>It&rsquo;s aother rails convention for the path <code>/controllers/admin/</code> and class name <code>Admin::</code>.</p></blockquote>

<p>Then add <code>admin</code> column to migration</p>

<p><code>$ rails g migration add_admin_to_users</code></p>

<pre><code>add_column :users, :admin, :boolean
</code></pre>

<p>Rails will create a method for all boolean attributes: <code>admin?</code></p>

<h3>Secure Access for different roles</h3>

<p>Next, we can create a <code>AdminController</code> for all other controllers belongs to Admin.</p>

<pre><code>class AdminController &lt; ApplicationController
  before_filter :ensure_admin

  def ensure_admin
    if !current_user.admin?
      #do something
    end
  end
end
</code></pre>

<p>Then other controllers belong to Admin could be like this:</p>

<pre><code>class Admin::TodoController &lt; AdminController
  def index
    @todo = Todo.all
  end
end
</code></pre>

<h3>CarrierWave upload images to AWS S3</h3>

<p>Install gem</p>

<pre><code>gem 'carrierwave'
gem 'mini_magick'
</code></pre>

<p>Add column to stored migration, for example: videos</p>

<p><code>$rails migration add_large_cover_to_videos</code></p>

<pre><code>add_column :videos, :large_cover, :string
</code></pre>

<p>In <code>models/video.rb</code></p>

<pre><code>mount_uploader :large_cover, LargeCoverUploader
</code></pre>

<p>Create <code>app/uploaders/large_cover_uploader.rb</code>, and use <code>mini_magick to resize image</code></p>

<pre><code>class LargeCoverUploader &lt; CarrierWave::Uploader::Base
  include CarrierWave::MiniMagick
  process :resize_to_fill =&gt; [665, 375]
end
</code></pre>

<p>Finally, set CarrierWave for AWS S3, in <code>initializers/carrier_wave.rb</code></p>

<pre><code>CarrierWave.configure do |config|
  config.fog_provider = 'fog/aws'                        # required
  config.fog_credentials = {
    provider:              'AWS',                        # required
    aws_access_key_id:     'xxx',                        # required
    aws_secret_access_key: 'yyy',                        # required
    region:                'eu-west-1',                  # optional, defaults to 'us-east-1'
    host:                  's3.example.com',             # optional, defaults to nil
    endpoint:              'https://s3.example.com:8080' # optional, defaults to nil
  }
  config.fog_directory  = 'name_of_directory'                          # required
  config.fog_public     = false                                        # optional, defaults to true
  config.fog_attributes = { 'Cache-Control' =&gt; "max-age=#{365.day.to_i}" } # optional, defaults to {}
end
</code></pre>

<p>Unfortunately, my AWS account has been suspended, so I change the code to store at local</p>

<pre><code>CarrierWave.configure do |config|
  if Rails.env.staging? || Rails.env.production?
    config.storage = :file
    config.enable_processing = true
  else
    config.storage = :file
    config.enable_processing = Rails.env.development?
  end
end
</code></pre>

<p>This code also show that if you want to deal with different environment for <code>product</code> or <code>development</code></p>

<blockquote><p>Usually, only upload small size files direct through web page, we can use other AWS S3 client to upload big file.</p></blockquote>

<p>Another tip here, don&rsquo;t forget to add new attributes to <code>params.require</code>, otherwise upload will be failed.</p>

<pre><code>params.require(:video).permit(:title, :description, :category_id, :large_cover, :small_cover, :video_url)
</code></pre>

<h3>RSpec Feature Test</h3>

<p>Key Points:</p>

<ul>
<li>attach_file</li>
<li>have_selector</li>
</ul>


<pre><code>feature 'Admin adds new video' do
  scenario 'Admin successfully adds a new video' do
    admin = Fabricate(:admin)
    dramas = Fabricate(:category, title: 'Dramas')

    sign_in(admin)
    visit new_admin_video_path

    fill_in 'Title', with: 'Monk'
    select 'Dramas', from: 'Category'
    fill_in 'Description', with: 'SF detective'
    attach_file 'Large cover', 'spec/support/uploads/monk_large.jpg'
    attach_file 'Small cover', 'spec/support/uploads/monk.jpg'
    fill_in 'Video URL', with: 'http://www.example.com/video.mp4'
    click_button 'Add Video'

    sign_out
    sign_in

    visit video_path(Video.first)
    expect(page).to have_selector("img[src='/uploads/monk_large.jpg']")
    expect(page).to have_selector("a[href='http://www.example.com/video.mp4']")
  end
end
</code></pre>
]]></content>
  </entry>
  
</feed>
