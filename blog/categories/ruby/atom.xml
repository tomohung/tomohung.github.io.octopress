<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | The Life Alchemist]]></title>
  <link href="http://www.tomohung.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.tomohung.com/"/>
  <updated>2015-04-26T23:39:05+08:00</updated>
  <id>http://www.tomohung.com/</id>
  <author>
    <name><![CDATA[Tomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -4]]></title>
    <link href="http://www.tomohung.com/blog/2015/04/26/eloquent-ruby-4/"/>
    <updated>2015-04-26T21:25:50+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/04/26/eloquent-ruby-4</id>
    <content type="html"><![CDATA[<h1>Chapter 4 - Take Advantage of Ruby’s Smart Strings</h1>

<p>string也和array, hash一樣有豐富的函式庫</p>

<p><a href="http://ruby-doc.org/core-2.2.2/String.html">http://ruby-doc.org/core-2.2.2/String.html</a></p>

<p>本章的結論就有Ruby提供的string非常好用，但壞處就是你要熟讀它。</p>

<hr />

<ul>
<li>double quoted string &ldquo;, 比&#8217;還多了點用途</li>
</ul>


<p>像是在字串中加入變數時#{}，我常忘了用&#8217;就沒有這個效果。</p>

<pre><code>"Hi, #{user.name}."
</code></pre>

<ul>
<li>遇到很煩的字串含有一堆單引號雙引號，可以用</li>
</ul>


<pre><code>%q{"Oh No", "I can't tell what's the difference between 's' and "s"."}
</code></pre>

<p>像上面的小寫q，也有對應用大寫Q的，效果就是像要加入變數時用：</p>

<pre><code>%Q{ "Hi, I'm #{user.name}."}
</code></pre>

<ul>
<li>可以隨意斷行</li>
</ul>


<pre><code>multi_line_string = '你抓
不到我
'

another_multi_line_string = %q{ 你抓
不到我 }
</code></pre>

<p>如果不想有new line，可以用back slash</p>

<pre><code>multi_line_with_no_new_line = '你抓\
不到我'
</code></pre>

<ul>
<li>超長文字可以這樣寫</li>
</ul>


<pre><code>really_long_string = &lt;&lt;EOF
這是開頭
...
這是結尾
EOF
</code></pre>

<ul>
<li>chop &amp; chomp</li>
</ul>


<p>長的很像的兩個函數，用法天差地遠</p>

<pre><code>"a string with new line\n".chomp
</code></pre>

<p>會回傳 <code>a string with new line</code>，尾巴的new line會截掉。注意如果結尾含有多個new line，它只會截掉一個。</p>

<pre><code>"a string".chop
</code></pre>

<p>會回傳&#8221;a strin&#8221;，回傳截掉最後一個字的結果。</p>

<ul>
<li>sub &amp; gsub</li>
</ul>


<p>替換字串內容</p>

<pre><code>puts 'good good'.sub( 'good', 'bad' )
puts 'good good'.gsub( 'good', 'bad' )
</code></pre>

<p>得到的結果是</p>

<pre><code>'bad good'
'bad bad'
</code></pre>

<ul>
<li>split 分割字串</li>
</ul>


<pre><code>"one two three four five".split
</code></pre>

<p>回傳一個矩陣</p>

<pre><code>["one", "two", "three", "four", "five"]
</code></pre>

<p>或是分割參數</p>

<pre><code>"one;two;three;four;five".split(";")
</code></pre>

<p>回傳結果同上</p>

<ul>
<li>index 搜尋字串位置</li>
</ul>


<pre><code>"actions speak louder than words".index("speak") # return 8
</code></pre>

<ul>
<li>each_char, each_byte, each_line</li>
</ul>


<p>分別用迴圈回傳字元，位元數，每一行</p>

<ul>
<li>Ruby string is mutable</li>
</ul>


<p>mutable雖然翻譯是可變異，但我覺得它的意義和指標有點類似</p>

<pre><code>street_name = 'taiwan street'
road_name = street_name
street_name.upcase!
</code></pre>

<p>結果road_name = ?</p>

<p>注意像帶有!的函數常會有mutate的作用，所以上述結果road_name = &lsquo;TAIWAN STREET&rsquo;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -3]]></title>
    <link href="http://www.tomohung.com/blog/2015/04/24/eloquent-ruby-3/"/>
    <updated>2015-04-24T16:33:18+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/04/24/eloquent-ruby-3</id>
    <content type="html"><![CDATA[<h1>Chapter 3 - Take Advantage of Ruby’s Smart Collections</h1>

<p>直接結論，Ruby的Array跟Hash提供很多方便的函數可用，可以參考</p>

<p><a href="http://ruby-doc.org/core-2.2.0/Array.html">Array</a>
<a href="http://ruby-doc.org/core-2.2.0/Hash.html">Hash</a></p>

<p>以下才是正文開始</p>

<hr />

<ul>
<li>如果是要初始化一個給值的陣列，如</li>
</ul>


<pre><code>love_words = ["Nancy", "I", "love", "you"]
</code></pre>

<p>也可以這樣產生
<code>
love_words = %w{ Nancy I love you }
</code></p>

<p>－ Ruby沒有指標，但是也有個類似指標的用法</p>

<pre><code>def echo_all( *args )
  args.each { |arg| puts arg }
end
</code></pre>

<p>*暗示arg其實是個陣列值，可以遞進來做陣列處理。</p>

<ul>
<li>對於hash，可以這樣用</li>
</ul>


<pre><code>run( {speed: :fast, tools: :train} )
</code></pre>

<p>也可以不要大括號，這樣寫</p>

<pre><code>run( speed: :fast, tools: :train )
</code></pre>

<p>甚至</p>

<pre><code>run speed: :fast, tools: :train
</code></pre>

<p>不過在參數只傳遞一個hash時，這樣寫蠻清爽的，如果是像form_for中要傳html_options時還這樣寫，簡直是個閱讀災難，我被誤導了好久。</p>

<p>－ 雖然array和hash都有提供each這個method，不過hash在使用上有些不一樣的地方</p>

<p>只給定一個參數的話
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash_value = { one: 1, two: 2, three: 3 }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;hash_value.each do |value|
</span><span class='line'>  #something for value
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>value其實是個矩陣，如[:one, 1], [:two, 2], [:three, 3]。</p>

<p>也可以給2個參數</p>

<pre><code>hash_value.each do |key, value|
  #something for value
end
</code></pre>

<p>key和value就分別對應到hash值上，這就不用多說了。</p>

<ul>
<li>另外有個<code>inject</code> method可以幫助加總所有元素</li>
</ul>


<pre><code>def average_word_length
  total = words.inject(0.0){ |result, word| word.size + result}
  total / word_count
end
</code></pre>

<p>－ 不要再each裡面操作delete的動作，如果需要的話可以用<code>array.delete_if</code> method。</p>

<p>－ 如果只是要檢查某個元素有沒有已經存在陣列中，可以考慮改用<code>Set</code>這個class，而不是用Array。
<a href="http://ruby-doc.org/stdlib-2.2.2/libdoc/set/rdoc/Set.html">http://ruby-doc.org/stdlib-2.2.2/libdoc/set/rdoc/Set.html</a></p>

<p>它在檢查效率上比較好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -2]]></title>
    <link href="http://www.tomohung.com/blog/2015/04/24/eloquent-ruby-2/"/>
    <updated>2015-04-24T15:37:46+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/04/24/eloquent-ruby-2</id>
    <content type="html"><![CDATA[<h1>Chapter 2 - Choose the Right Control Structure</h1>

<p>說是Control Structure，我比較習慣說Control Flow，簡單就是說幾乎所有程式語言都有的流程控制語法，像是if, while, case等。</p>

<ul>
<li>Ruby比較特別的是有unless, until反向詞語，一開始用不大習慣，但後來寫著寫著，心裡慢慢習慣照著口語的語法說，現在反而比較喜歡這樣寫了，總之照Ruby的理念就是這些反向詞語的目的就是為了要減少在閱讀程式碼時，心裡還需要做轉換的浪費。</li>
</ul>


<pre><code>if not @read_only
</code></pre>

<p>看到not心裡還要先把@read_only的值反向</p>

<pre><code>unless @read_only
</code></pre>

<p>讀起來比較順口</p>

<ul>
<li>另一個蠻特別的點是，條件式可以放在最後面，也是為了配合口語語法</li>
</ul>


<pre><code>@title = new_title unless @read_only
</code></pre>

<ul>
<li><p>Ruby也有for迴圈，不過直接被捨棄不用（那當初幹嘛創造=___=），都用<code>each</code>。而且<code>for</code>也是用each實踐的，所以直接用each就好了。註：for語法不包含block，所以內中的變數scope是和for同一個，和each只存在於block中不一樣，each和for還是有些不同。</p></li>
<li><p>case, 要注意的是在case中比較是用<code>===</code>，另外條件式也可以用regex來比較</p></li>
</ul>


<p>這邊惡補一下幾個我不熟的operator</p>

<p><code>&lt;=&gt;</code>
Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second and -1 if first operand is less than the second.</p>

<p><code>(a &lt;=&gt; b) returns -1.</code></p>

<p><code>===</code>
Used to test equality within a when clause of a case statement.</p>

<p><code>(1...10) === 5 returns true.</code></p>

<p><code>.eql?</code>
True if the receiver and argument have both the same type and equal values.</p>

<p><code>1 == 1.0 returns true, but 1.eql?(1.0) is false.</code></p>

<p><code>equal?</code>
True if the receiver and argument have the same object id.</p>

<p><code>if aObj is duplicate of bObj then aObj == bObj is true, a.equal?bObj is false but a.equal?aObj is true.</code></p>

<ul>
<li><p>只有false和nil被測試時才會回傳false，<code>0</code>不是！還特別highlight以前寫C的人（哈哈），因為在C裡面<code>0</code>值被測試也是算false</p></li>
<li><p>延續上，因為false和nil被測試都是回傳false，所以要特別注意條件式中會不會false和nil混在一起</p></li>
</ul>


<pre><code>while next_object = get_next_object
  # Do something with the object
end
</code></pre>

<p>上面的迴圈是假設next_object最後會變成nil，而nil測試後回傳false。但萬一今天next_object本身的值就是false呢。改成下面的碼會比較好</p>

<pre><code>until (next_object = get_next_object).nil?
  # Do something with the object
end
</code></pre>

<p>明確指定出next_object是nil才會跳離迴圈</p>

<ul>
<li>Ternery operator</li>
</ul>


<p>這個以前在C++我就蠻愛用的，可以很漂亮的縮短一些簡單的if-else</p>

<pre><code>result = (face == :beauty) ? "handsome" : "ugly" # 同等於下式

if face == :beauty
 result = "handsome"
else
 result = "ugly"
end
</code></pre>

<ul>
<li>另一個是常用的變數初始化技巧</li>
</ul>


<pre><code>@first_name ||= ''
</code></pre>

<p>@first_name如果還沒初始化，會被賦值&#8217;&lsquo;，如果已經有值，那就回傳本身。不過不要拿來對boolean type的變數這樣做，因為它也是倚賴 || operator機制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -1]]></title>
    <link href="http://www.tomohung.com/blog/2015/04/24/eloquent-ruby-1/"/>
    <updated>2015-04-24T14:15:45+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/04/24/eloquent-ruby-1</id>
    <content type="html"><![CDATA[<h1>Eloquent Ruby</h1>

<p><code>Eloquent Ruby</code> by Russ Olsen 是一本在Tealeaf推薦的書，但它是所謂的『第二本Ruby的書』，而不是第一本，因為這本書裡面已經假設你對Ruby有基礎的觀念了。如果真的完全是初學者，Tealeaf推薦<a href="https://pine.fm/LearnToProgram/">Learn to Program by Chris Pine</a>，或者是<a href="http://learnrubythehardway.org/book/">Learn Ruby The Hard Way</a>，我覺得也不錯，還可以一邊練習打字。</p>

<p>目前我把Part I：Basics看完了，共九章，覺得自己有學到些東西，所以就把它給紀錄下來，並參雜一些個人的想法。</p>

<h1>Charpter 1 - Write Code That Looks Like Ruby</h1>

<p>其實這章指的就是Code Style。更多的Ruby Code Style可以參考<a href="https://github.com/bbatsov/ruby-style-guide">這裡</a>。</p>

<ul>
<li><p>Indent code with two spaces，以前在寫C++時就一直覺得縮排其實2個空白就夠了（雖然我還是用預設4個），轉成Ruby後倒是蠻習慣的，尤其是不用再寫分號跟括號。</p></li>
<li><p>什麼時候寫註解，告訴人家要怎麼用這個method，最好還帶範例。其它的像是最好用良好的命名去定義名稱，省去閱讀時的猜測，documenting itself.</p></li>
<li><p>如果是寫const value，最好用Uppercase with underline，像UPPERCASE_WITH_UNDERLINE。</p></li>
<li><p>因為括號是可以省略的，所以⋯⋯我常被搞混=___=，書用建議def method時後面帶參數時要用括號，但如果是一些接近口語的句子時可以考慮拿掉，如</p></li>
</ul>


<pre><code>puts 'hello world'。
</code></pre>

<ul>
<li>如果code block只有一行時最好縮成一排，反過來說如果是多行的話就用block</li>
</ul>


<pre><code>apples.each { |apple| apple.to_eat } # prefer if only single code statement

apples.each do |apple|
  apple.to_eat
end
</code></pre>

<ul>
<li><p>如果method name結尾帶一個問號?，通常表示這個方法回傳true or false，如<code>array.nil?</code>；又如果是驚嘆號!，通常表示可能有點危險（所謂的危險通常是把丟進來的參數被改變mutate了，如<code>array.map!</code>。但是不管是問號還是驚嘆號，都只是Ruby習慣的命名而已，不是強制性。</p></li>
<li><p>有慣例就會有例外，像是</p></li>
</ul>


<pre><code> pi = Float('3.14159')
</code></pre>

<p>Float開頭是大寫而不是小寫。為什麼我也不知道@_@</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Show HTTP Is Stateless by Sinatra]]></title>
    <link href="http://www.tomohung.com/blog/2015/01/14/show-http-is-stateless-by-sinatra/"/>
    <updated>2015-01-14T21:25:15+08:00</updated>
    <id>http://www.tomohung.com/blog/2015/01/14/show-http-is-stateless-by-sinatra</id>
    <content type="html"><![CDATA[<p>In tealeaf week 3, introduce to HTTP.</p>

<p>The most important thing is that, HTTP is stateless.</p>

<p>What&rsquo;s the influnce by this property? Showing this by Sinatra.</p>

<!--more-->


<p>first, follow <a href="http://www.sinatrarb.com/intro.html">Sinatra intro</a> to run basic function:
then try this code:</p>

<pre><code class="ruby main.rb">require 'sinatra'

before do
  @name = 'Guest'
end

get '/' do
  erb :home
end

post '/set_name' do
  @name = 'tealeaf'
  redirect '/'
end
</code></pre>

<p>and this will show a button, click the button will invoke a post request back to <code>set_name</code> in main.rb:</p>

<p>&#8220;` erb home.erb</p>

<h4>hi~ <%= @name %> </h4>


<p><form action="/set_name" method="post">
  <input class="btn" type="submit" name="name">
</form>
&#8220;`</p>

<p>OK, then what will <code>@name</code> show in home.erb after click button??</p>

<p>It shows <code>Guest</code>, not <code>tealeaf</code>. Why?</p>

<p><img class="<a" src="href="http://i.minus.com/i9oeLWDYI4DBb.png">http://i.minus.com/i9oeLWDYI4DBb.png</a>&#8221;></p>

<p>The key point is: when 2 redirect to 3, it&rsquo;s a new request, instance variable like @name will be deleted after redirect, then create a new one.</p>

<p>That&rsquo;s why @name still shows <code>Guest</code>.</p>

<p>How about this way:</p>

<pre><code class="ruby main.rb">require 'sinatra'

before do
  @name = 'Guest'
end

get '/' do
  erb :home
end

post '/set_name' do
  @name = 'tealeaf'
  erb :home
end
</code></pre>

<p>Now using erb to embeded <code>home.erb</code> into the same request(&lsquo;/set_name&rsquo;). Then you&rsquo;ll see <code>@name</code> shows <code>tealeaf</code>!!</p>

<p>This experience shows me how HTTP is stateless.</p>

<p>And how web developers make it like stateness is a long way to go.</p>
]]></content>
  </entry>
  
</feed>
